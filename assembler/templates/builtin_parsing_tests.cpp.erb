/*
 * Copyright (c) 2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <iostream>
#include <string>

#include <gtest/gtest.h>
#include "assembly-parser.h"
#include "define.h"
#include "lexer.h"
#include "operand_types_print.h"

using namespace panda::pandasm;

% PandaBuiltins::builtins.each do |builtin|
%
TEST(builtinparsingtests, builtins_<%=builtin.insn.tr('.', '_')%>_id<%=builtin.id%>)
    {
        Parser p;
        std::string src = std::string(R"(
            .function void g() {
                <%=builtin.insn%> <%=builtin.mnemonic%>)"
% PandaBuiltins::instructions.each do |insn|
%
% if (insn.mnemonic == builtin.insn)
% 
% insn.sig.split(', ').each_with_index do |op, i|
%    if (i != 0)
%       if (op.start_with?('v'))
                                      ", v<%=i%>"
%       elsif (op.start_with?('imm'))
                                      ", <%=i%>"
%       elsif (op == 'type_id')
                                      ", A"
%       elsif (op == 'method_id')
                                      ", g"
%       elsif (op == 'string_id')
                                      ", \"string_string\""
%       elsif (op == 'field_id')
                                      ", A.B"
%       end
%    end
% end
% 
% end
% end
                                      "\nreturn.void\n}\n");

        auto res = p.Parse(src);

        Error e = p.ShowError();

        ASSERT_EQ(e.err, Error::ErrorType::ERR_NONE);
    }
%
% end

% PandaBuiltins::instructions.each do |insn|
%
TEST(builtinparsingtests, builtins_<%=insn.mnemonic.tr('.', '_')%>_bad_mnemonic_name) {
    {
        Parser p;
        std::string src = std::string(R"(
            .function void g() {
                <%=insn.mnemonic%> wrong_mnemonic)"
% insn.sig.split(', ').each_with_index do |op, i|
%    if (i != 0)
%       if (op.start_with?('v'))
                                      ", v<%=i%>"
%       elsif (op == 'imm')
                                      ", <%=i%>"
%       elsif (op == 'type_id')
                                      ", A"
%       elsif (op == 'method_id')
                                      ", g"
%       elsif (op == 'string_id')
                                      ", \"string_string\""
%       elsif (op == 'field_id')
                                      ", A.B"
%       end
%    end
% end
                                      "\nreturn.void\n}\n");

        auto res = p.Parse(src);

        Error e = p.ShowError();

        ASSERT_EQ(e.err, Error::ErrorType::ERR_BAD_MNEMONIC_NAME);
    }
}
%
% end

% PandaBuiltins::instructions.each do |insn|
%
TEST(builtinparsingtests, builtins_<%=insn.mnemonic.tr('.', '_')%>_bad_operand) {
    {
        Parser p;
        std::string src = std::string(R"(
            .record A {
                u1 B
            }
            .function void g() {
                <%=insn.mnemonic%> "")"
% insn.sig.split(', ').each_with_index do |op, i|
%    if (i != 0)
%       if (op.start_with?('v'))
                                      ", v<%=i%>"
%       elsif (op == 'imm')
                                      ", <%=i%>"
%       elsif (op == 'type_id')
                                      ", A"
%       elsif (op == 'method_id')
                                      ", g"
%       elsif (op == 'string_id')
                                      ", \"string_string\""
%       elsif (op == 'field_id')
                                      ", A.B"
%       end
%    end
% end
                                      "\nreturn.void\n}\n");

        auto res = p.Parse(src);

        Error e = p.ShowError();

        ASSERT_EQ(e.err, Error::ErrorType::ERR_BAD_OPERAND);
    }
}
%
% end

