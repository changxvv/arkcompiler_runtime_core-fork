{% for arg, fwdArg, prec in [('', '', '(%s < %s)'), (', mustPrecede: (lhs: ' + T + ', rhs: ' + T + ') => boolean', ', mustPrecede', 'mustPrecede(%s, %s)')] %}
{%- if T == 'Object' and arg == '' %}
{%- continue %}
{%- elif T == 'boolean' and arg == '' %}
{%- set prec = '((%s) ? 1 : 0) < ((%s) ? 1 : 0)' %}
{%- endif %}
function bubbleSort(arr: {{T}}[], startIndex: int, endIndex: int{{arg}}): void {
    let was = true
    while (was) {
        was = false
        for (let i = startIndex; i < endIndex - 1; i++) {
            if ({{prec % ('arr[i + 1]', 'arr[i]')}}) {
                const tmp = arr[i + 1]
                arr[i + 1] = arr[i]
                arr[i] = tmp
                was = true
            }
        }
    }
}

{%- if T != "boolean" %}
function heapSortUp(arr: {{T}}[], idxFromStart: int, startIndex: int, endIndex: int{{arg}}): void {
    while (idxFromStart != 0) {
        const p = (idxFromStart - 1) / 2
        if ({{prec % ('arr[startIndex + idxFromStart]', 'arr[startIndex + p]')}}) {
            break
        }
        const tmp = arr[startIndex + idxFromStart]
        arr[startIndex + idxFromStart] = arr[startIndex + p]
        arr[startIndex + p] = tmp
        idxFromStart = p
    }
    heapSortDown(arr, idxFromStart, startIndex, endIndex{{fwdArg}})
}

function heapSortDown(arr: {{T}}[], idxFromStart: int, startIndex: int, endIndex: int{{arg}}): void {
    while (true) {
        const l = idxFromStart * 2 + 1
        const r = idxFromStart * 2 + 2
        let best = idxFromStart
        if (startIndex + l < endIndex && {{prec % ('arr[startIndex + best]', 'arr[startIndex + l]')}}) {
            best = l
        }
        if (startIndex + r < endIndex && {{prec % ('arr[startIndex + best]', 'arr[startIndex + r]')}}) {
            best = r
        }
        if (best == idxFromStart) {
            return
        }
        const tmp = arr[startIndex + idxFromStart]
        arr[startIndex + idxFromStart] = arr[startIndex + best]
        arr[startIndex + best] = tmp
        idxFromStart = best
    }
}

function heapSort(arr: {{T}}[], startIndex: int, endIndex: int{{arg}}): void {
    let len = endIndex - startIndex
    for (let i = 1; i < len; i++) {
        heapSortUp(arr, i, startIndex, startIndex + i + 1{{fwdArg}})
    }
    for (let i = len - 1; i >= 0; i--) {
        const tmp = arr[startIndex + i]
        arr[startIndex + i] = arr[startIndex]
        arr[startIndex] = tmp
        heapSortDown(arr, 0, startIndex, startIndex + i{{fwdArg}})
    }
}

function quickSortSplit(arr: {{T}}[], startIndex: int, endIndex: int{{arg}}): int {
    const pivot = arr[startIndex + (endIndex - startIndex) / 2]
    let i = startIndex
    let j = endIndex - 1
    while (i < j) {
        while ({{prec % ('arr[i]', 'pivot')}}) {
            i++
        }
        while ({{prec % ('pivot', 'arr[j]')}}) {
            j--
        }
        if (i >= j) {
            break
        }
        let tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
        // we must not leave pivot outside of [i, j] range
        if ({{prec % ('arr[i]', 'pivot')}}) {
            i++
        } else { // arr[i] == pivot
            j--
        }
    }

    return j
}

{% for quickUpTo in [1, 15] %}
function quickSortImpl{{quickUpTo}}(arr: {{T}}[], startIndex: int, endIndex: int, bits: int{{arg}}): void {
    const bits1 = bits * 3

    let iter = 0
    while (endIndex - startIndex > {{quickUpTo}}) {
        if (iter++ > bits1) {
            heapSort(arr, startIndex, endIndex{{fwdArg}})
            return
        }

        let p = quickSortSplit(arr, startIndex, endIndex{{fwdArg}})
        if (p - startIndex < endIndex - p) {
            quickSortImpl{{quickUpTo}}(arr, startIndex, p, bits - 1{{fwdArg}})
            startIndex = p
        } else {
            quickSortImpl{{quickUpTo}}(arr, p, endIndex, bits - 1{{fwdArg}})
            endIndex = p
        }
    }
{%- if quickUpTo > 1 %}
    bubbleSort(arr, startIndex, endIndex{{fwdArg}})
{%- endif %}
}
{%- endfor %}

function quickSort(arr: {{T}}[], startIndex: int, endIndex: int{{arg}}): void {
    let size = endIndex - startIndex
    if (size == 0) {
        return
    }
    // find log of length to fall back into determenistic O(n logn) sort
    size -= 1
    size |= size >> 1
    size |= size >> 2
    size |= size >> 4
    size |= size >> 8
    size |= size >> 16
    size += 1
    let bits = -1
    for (let i = 0; i < 31; i++) {
        if ((size & 1 << i) != 0) {
            bits = i
            break
        }
    }
    assert bits != -1
    quickSortImpl15(arr, startIndex, endIndex, bits{{fwdArg}})
}
{%- endif %}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 *
 * @param startIndex an index to start sorting with, inclusive
 *
 * @param endIndex an index to end sorting, exclusive
 *
 * @example: sort array arr
 * ```
 * sort(arr, 0, arr.length)
 * ```
 */
export function sort(arr: {{T}}[], startIndex: int, endIndex: int{{arg}}): void {
    if (!checkRange(arr.length, startIndex, endIndex)) {
        throw new ArrayIndexOutOfBoundsError("sort: bounds verification failed")
    }

    {% if T == "boolean" -%}
        {%- if arg == '' %}
    countSortBools(arr, startIndex, endIndex)
        {%- else %}
    if ({{prec % ('false', 'true')}}) {
        countSortBools(arr, startIndex, endIndex)
    } else {
        countSortBoolsInv(arr, startIndex, endIndex)
    }
        {%- endif %}
    {%- else %}
    {% if T == "byte" and arg == '' %}
    if (endIndex - startIndex > 1024) {
        countSort(arr, startIndex, endIndex)
    }
    {%- endif %}
    quickSort(arr, startIndex, endIndex{{fwdArg}});
    {%- endif %}
}

{% endfor %}

/**
 * sorts arr in-place
 *
 * @param arr an array to sort
 */
export function sort(arr: {{T}}[], mustPrecede: (lhs: {{T}}, rhs: {{T}}) => boolean): void {
    sort(arr, 0, arr.length, mustPrecede);
}

export function sort(arr: {{T}}[], startIndex: int, mustPrecede: (lhs: {{T}}, rhs: {{T}}) => boolean): void {
    sort(arr, startIndex, arr.length, mustPrecede)
}

{% if T != "Object" -%}

{%- if T == 'byte' %}
function countSort(arr: byte[], startIndex: int, endIndex: int): void {
    const cnts = new int[256]
    for (let i = startIndex; i < endIndex; i++) {
        cnts[arr[i] + 128]++
    }
    let idx = 0
    for (let i = 0; i < 256; i++) {
        for (let j = 0; j < cnts[i]; j++) {
            arr[startIndex + idx++] = (i - 128) as byte
        }
    }
}
{%- elif T == 'boolean' %}
function countSortTruthCnt(arr: boolean[], startIndex: int, endIndex: int): int {
    let truthCnt = 0
    for (let i = startIndex; i < endIndex; i++) {
        if (arr[i]) {
            truthCnt++
        }
    }
    return truthCnt
}

function countSortBools(arr: boolean[], startIndex: int, endIndex: int): void {
    const truthCnt = countSortTruthCnt(arr, startIndex, endIndex)
    for (let i = startIndex; i < endIndex - truthCnt; i++) {
            arr[i] = false
        }
    for (let i = 0; i < truthCnt; i++) {
        arr[endIndex - truthCnt + i] = true
    }
}
function countSortBoolsInv(arr: boolean[], startIndex: int, endIndex: int): void {
    const truthCnt = countSortTruthCnt(arr, startIndex, endIndex)
    for (let i = 0; i < truthCnt; i++) {
        arr[startIndex + i] = true
    }
    for (let i = startIndex + truthCnt; i < endIndex; i++) {
        arr[i] = false
    }
}
{%- endif %}

export function sort(arr: {{T}}[], startIndex: int): void {
    sort(arr, startIndex, arr.length)
}

export function sort(arr: {{T}}[]): void {
    sort(arr, 0, arr.length)
}

// ======== tests section ========

/** note: used for tests, {@link test_sortAllOn} */
class test_SortData{{T}} {
    name: string
    arr: {{T}}[]

    constructor(name: string, arr: {{T}}[]) {
        this.name = name
        this.arr = arr
    }
}

/** note: used for tests, {@link test_sortAllOn} */
function test_sortCopy(arr: {{T}}[]): {{T}}[] {
    let c = new {{T}}[arr.length]
    for (let i = 0; i < arr.length; i++) {
        c[i] = arr[i]
    }
    return c
}

/** note: used for tests, {@link test_sortAllOn} */
function test_sortAllOnCmpFwd(l: {{T}}, r: {{T}}): boolean {
{%- set mapMPArg = '%s' if T != 'boolean' else '((%s) ? 1 : 0)' %}
    return {{mapMPArg % 'l'}} < {{mapMPArg % 'r'}}
}

/** note: used for tests, {@link test_sortAllOn} */
function test_sortAllOnCmpInv(l: {{T}}, r: {{T}}): boolean {
    return {{mapMPArg % 'r'}} < {{mapMPArg % 'l'}}
}

/** note: used for tests, {@link test_sortAllOn} */
function test_printArr(arr: {{T}}[], startIndex: int, endIndex: int) {
    for (let i = startIndex; i < endIndex; i++) {
        console.print(arr[i] + ' ')
    }
    console.println('')
}

/**
 * Function used to test sorting in standard library tests.
 * There is only one exported function: `sort`, but for testing
 * we need access to all sub sorts that are used. Hence this part of "tests"
 * is located here. All related entities are prefixed whith `test_` to stand out
 */
export function test_sortAllOn(arr: {{T}}[]) {
    {%- for arg in ['', ', test_sortAllOnCmpFwd', ', test_sortAllOnCmpInv'] %}
    // block for comparator `{{arg[3:]}}`
    if (true) {
        const sorts: test_SortData{{T}}[] = new test_SortData{{T}}[10]
        let lastSort = 0
        const bubbled = test_sortCopy(arr)
        bubbleSort(bubbled, 0, bubbled.length{{arg}})
        sorts[lastSort++] = new test_SortData{{T}}("bubble", bubbled)

        {%- if T == 'byte' and arg == '' %}
        const cnt = test_sortCopy(arr)
        countSort(cnt, 0, cnt.length)
        sorts[lastSort++] = new test_SortData{{T}}("cnt()", cnt)
        {%- endif %}

        {% if T == 'boolean' %}
        const bcnt = test_sortCopy(arr)
            {%- if arg != ', test_sortAllOnCmpInv' %}
        countSortBools(bcnt, 0, bcnt.length)
            {%- else %}
        countSortBoolsInv(bcnt, 0, bcnt.length)
            {%- endif %}
        sorts[lastSort++] = new test_SortData{{T}}("bools cnt()", bcnt)
        {%- else %}
        const heaped = test_sortCopy(arr)
        heapSort(heaped, 0, heaped.length{{arg}})
        sorts[lastSort++] = new test_SortData{{T}}("heap", heaped)

        const quicked = test_sortCopy(arr)
        quickSortImpl1(quicked, 0, quicked.length, quicked.length{{arg}})
        sorts[lastSort++] = new test_SortData{{T}}("quick", quicked)

        const quickedBuble = test_sortCopy(arr)
        quickSortImpl15(quickedBuble, 0, quickedBuble.length, quickedBuble.length{{arg}})
        sorts[lastSort++] = new test_SortData{{T}}("quick with bubble", quickedBuble)
        {%- endif %}

        const just = test_sortCopy(arr)
        sort(just{{arg}})
        sorts[lastSort++] = new test_SortData{{T}}("sort()", just)

        for (let s = 1; s < lastSort; s++) {
            for (let i = 0; i < arr.length; i++) {
                if (sorts[0].arr[i] != sorts[s].arr[i]) {
                    console.println(sorts[0].name + ': ')
                    test_printArr(sorts[0].arr, 0, arr.length)
                    console.println(sorts[s].name + ': ')
                    test_printArr(sorts[s].arr, 0, arr.length)
                    throw new Error("sorts {{arg[3:]}} are not equal: " + sorts[0].name + ' ' + sorts[s].name + ' for {{T}}')
                }
            }
        }
    }
    {%- endfor %}
}
// ======== end of tests section ========
{% endif %}
