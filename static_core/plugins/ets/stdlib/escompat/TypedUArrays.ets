/*
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file. DO NOT EDIT
package escompat;

/**
 * JS Uint8ClampedArray API-compatible class
 */
export class Uint8ClampedArray
{
    public static readonly BYTES_PER_ELEMENT = 1

    /**
     * Creates an empty Uint8ClampedArray.
     */
    public constructor() {
        this.length = 0
        this.byteLength = 0
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(0)
    }

    /**
     * Creates an Uint8ClampedArray with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint8ClampedArray
     */
    public constructor(buf: ArrayBuffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Uint8ClampedArray with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint8ClampedArray
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        if (buf.byteLength % Uint8ClampedArray.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 1 as Uint8ClampedArray.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Uint8ClampedArray.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 1 as Uint8ClampedArray.BYTES_PER_ELEMENT")
        }

        if (this.length * Uint8ClampedArray.BYTES_PER_ELEMENT > buf.byteLength) {
            throw new RangeError("Range Error: attempt to create Uint8ClampedArray where length * Uint8ClampedArray.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.byteLength - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Uint8ClampedArray with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, byteOffset, buf.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Uint8ClampedArray with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Uint8ClampedArray with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayBuffer)
    {
        this(buf, 0, buf.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT)
    }

     /**
     * Creates an Uint8ClampedArray with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int)
    {
        this.length = length
        this.byteLength = length * Uint8ClampedArray.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Uint8ClampedArray with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Uint8ClampedArray.
     *
     * @param other data initializer
     */
    public constructor(other: Uint8ClampedArray) {
        this.buffer = other.buffer.slice(0, other.buffer.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    /* public */ internal at(index: int): number
    {
        throw new Error("not implemented")
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int, endPos: int): void
    {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint8ClampedArray.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint8ClampedArray.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint8ClampedArray.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint8ClampedArray.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    // TODO(ivan-tyulyandin): blocked by tuples implentation
    // public entries(): Iterator<[Int, Object]> {
    //     let ret: Entry<Int, Object> = new Entry<Int, Object>[this.length];
    //     for (let i: int = 0; i < this.length; i++) {
    //         ret[i] = new Entry<Int, Object>(i, this.at(i));
    //     }
    //     return new MapIterator<Int, Object>(ret);
    // }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8ClampedArray
     */
    public fill(value: number, start: number, end: number): Uint8ClampedArray {
        return this.fill(value as number, start as int, end as int)
    }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8ClampedArray
     */
    /* public */ internal fill(value: number, start: int, end: int): Uint8ClampedArray {
        throw new Error("not implemented")
    }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8ClampedArray
     */
    public fill(value: number, start: number): Uint8ClampedArray {
        return this.fill(value as number, start as int)
    }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8ClampedArray
     */
    /* public */ internal fill(value: number, start: int): Uint8ClampedArray {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Uint8ClampedArray with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8ClampedArray
     */
    public fill(value: number): Uint8ClampedArray {
        return this.fill(value as number, 0, this.length)
    }



    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as number)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    /* public */ internal set(insertPos: int, val: number): void {
        throw new Error("not implemented")
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint8ClampedArray.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as number)
        }
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    /* public */ internal set(arr: number[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint8ClampedArray.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint8ClampedArray.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }



    /**
     * Creates an Uint8ClampedArray from array-like argument
     *
     * @param o array-like object to initialize Uint8ClampedArray
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint8ClampedArray
     */
    public from(o: Object, mapFn: (e: Object) => number): Uint8ClampedArray {
        let newF: (e: Object, index: int) => number =
            (e: Object, index: int): number => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Uint8ClampedArray from array-like argument
     *
     * @param o array-like object to initialize Uint8ClampedArray
     *
     * @returns new Uint8ClampedArray
     */
    public from(o: Object): Uint8ClampedArray {
        throw new Error("Uint8ClampedArray.from: not implemented")
    }

    /**
     * Checks if specified argument is in Uint8ClampedArray
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint8ClampedArray, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as number, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Uint8ClampedArray
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint8ClampedArray, false otherwise
     */
    /* public */ internal includes(e: number, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }

    /**
     * Checks if specified argument is in Uint8ClampedArray
     *
     * @param e search element
     *
     * @returns true if e is in Uint8ClampedArray, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as number, 0)
    }



    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as number, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    /* public */ internal indexOf(e: number, fromIndex: int): int {
        throw new Error("not implemented")
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as number)
    }



    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Uint8ClampedArray
     *
     * @returns iterator over keys
     */
    public keys(): Iterator<Int> {
        throw new Error("not implemented")
        // let ret: Int[] = new Int[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = i;
        // }
        // return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as number, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    /* public */ internal lastIndexOf(val: number, fromIndex: int): int
    {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as number, this.length - 1)
    }



   /**
    * Creates a new Uint8ClampedArray using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint8ClampedArray from data
    */
    public of(data: Object[]): Uint8ClampedArray {
        throw new Error("Uint8ClampedArray.of: not implemented")
    }

    /**
     * Creates a new Uint8ClampedArray using reversed data from the current one
     *
     * @returns a new Uint8ClampedArray using reversed data from the current one
     */
    public reverse(): Uint8ClampedArray {
        let res = new Uint8ClampedArray(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Uint8ClampedArray using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Uint8ClampedArray {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Uint8ClampedArray using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    /* public */ internal slice(begin: int, end: int): Uint8ClampedArray
    {
        if (begin < -this.length) {
            begin = 0
        }
        if (begin < 0) {
            begin = this.length + begin
        }
        if (begin >= this.length) {
            return new Uint8ClampedArray(new ArrayBuffer(0))
        }

        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end = this.length + end
        }
        if (end >= this.length) {
            end = this.length
        }

        if (end < begin) {
            return new Uint8ClampedArray(new ArrayBuffer(0))
        }

        let len = end - begin
        let resBuf = new ArrayBuffer(len * Uint8ClampedArray.BYTES_PER_ELEMENT)
        let res = new Uint8ClampedArray(resBuf)
        for (let i = 0; i < len; ++i) {
            res.set(i, this.at(i + begin))
        }
        return res
    }

    /**
     * Creates a slice of current Uint8ClampedArray using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray[begin, this.length)
     */
    public slice(begin: number): Uint8ClampedArray {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Uint8ClampedArray using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray[begin, this.length)
     */
    /* public */ internal slice(begin: int): Uint8ClampedArray {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Uint8Clamped with all elements.
     *
     * @returns a new Uint8ClampedArray with elements of current Uint8ClampedArray
     */
    public slice(): Uint8ClampedArray {
        return new Uint8ClampedArray(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Uint8ClampedArray
     */
    public sort(): Uint8ClampedArray {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => { throw new Error("not implemented") }
        return this.sort(newF)
    }

    /**
     * Creates a Uint8ClampedArray with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint8ClampedArray with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Uint8ClampedArray {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Uint8ClampedArray with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint8ClampedArray with the same underlying ArrayBuffer
     */
    /* public */ internal subarray(begin: int, end: int): Uint8ClampedArray {
        return new Uint8ClampedArray(this.buffer, begin * Uint8ClampedArray.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Uint8ClampedArray with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint8ClampedArray with the same ArrayBuffer
     */
    public subarray(begin: number): Uint8ClampedArray {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Uint8ClampedArray with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint8ClampedArray with the same ArrayBuffer
     */
    /* public */ internal subarray(begin: int): Uint8ClampedArray {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Uint8ClampedArray with the same ArrayBuffer
     *
     * @returns new Uint8ClampedArray with the same ArrayBuffer
     */
    public subarray(): Uint8ClampedArray {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Uint8ClampedArray to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint8ClampedArray.toLocaleString: not implemented")
    }

    /**
     * Converts Uint8ClampedArray to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint8ClampedArray to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint8ClampedArray {
        return new Uint8ClampedArray(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint8ClampedArray {
        return new Uint8ClampedArray(this).sort()
    }

    /**
     * Returns a string representation of the Uint8ClampedArray
     *
     * @returns a string representation of the Uint8ClampedArray
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): Iterator<Number> {
        throw new Error("not implemented")
        // const ret = new Number[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = this.at(i);
        // }
        // return new ValuesIterator<Number>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8ClampedArray with replaced value on index
     */
    public with(index: number, value: number): Uint8ClampedArray {
        return this.with(index as int, value as number)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8ClampedArray with replaced value on index
     */
    /* public */ internal with(index: int, value: number): Uint8ClampedArray {
        let res = new Uint8ClampedArray(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of Uint8ClampedArray satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int, array: Uint8ClampedArray) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint8ClampedArray satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8ClampedArray) => boolean =
            (element: number, index: int, array: Uint8ClampedArray): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint8ClampedArray) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint8ClampedArray) => number): number {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint8ClampedArray) => number, init: number): number {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint8ClampedArray) => number): number {
        let acc: number = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Uint8ClampedArray using fn(arr[i]) over all elements of current Uint8ClampedArray.
    *
    * @param fn a function to apply for each element of current Uint8ClampedArray
    *
    * @returns a new Uint8ClampedArray where for each element from current Uint8ClampedArray fn was applied
    */
    public map(fn: (val: number, index: int) => number): Uint8ClampedArray {
        let resBuf = new ArrayBuffer(this.length * Uint8ClampedArray.BYTES_PER_ELEMENT)
        let res = new Uint8ClampedArray(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Uint8ClampedArray satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int, array: Uint8ClampedArray) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint8ClampedArray satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8ClampedArray) => boolean =
            (element: number, index: int, array: Uint8ClampedArray): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint8ClampedArray from current Uint8ClampedArray based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8ClampedArray with elements from current Uint8ClampedArray that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): Uint8ClampedArray {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint8ClampedArray.BYTES_PER_ELEMENT)
        let res = new Uint8ClampedArray(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint8ClampedArray from current Uint8ClampedArray based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8ClampedArray with elements from current Uint8ClampedArray that satisfy condition fn
     */
    public filter(fn: (val: number, index: int) => boolean): Uint8ClampedArray {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint8ClampedArray.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint8ClampedArray.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint8ClampedArray) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Uint8ClampedArray
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int, array: Uint8ClampedArray) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Uint8ClampedArray.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint8ClampedArray
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int) => number): void {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => number =
            (val: number, index: int, array: Uint8ClampedArray): number => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint8ClampedArray from array-like argument
     *
     * @param o array-like object to initialize Uint8ClampedArray
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint8ClampedArray
     */
    public from(o: Object, mapFn: (e: Object, index: int) => number): Uint8ClampedArray {
        throw new Error("Uint8ClampedArray.from: not implemented")
    }
    /**
     * Checks that all elements of Uint8ClampedArray satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8ClampedArray) => boolean =
            (element: number, index: int, array: Uint8ClampedArray): boolean => { return fn(element as number) }
        return this.every(newF)
    }
    /**
     * creates a new Uint8ClampedArray from current Uint8ClampedArray based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8ClampedArray with elements from current Uint8ClampedArray that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Uint8ClampedArray {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint8ClampedArray
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => number): void {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => number =
            (val: number, index: int, array: Uint8ClampedArray): number => { return fn(val as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Uint8ClampedArray using fn(arr[i]) over all elements of current Uint8ClampedArray
    *
    * @param fn a function to apply for each element of current Uint8ClampedArray
    *
    * @returns a new Uint8ClampedArray where for each element from current Uint8ClampedArray fn was applied
    */
    public map(fn: (val: number) => number): Uint8ClampedArray
    {
        let newF: (val: number, index: int) => number =
            (val: number, index: int): number => { return fn(val as number) as number }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Uint8ClampedArray satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8ClampedArray) => boolean =
            (element: number, index: int, array: Uint8ClampedArray): boolean => { return fn(element as number) }
        return this.some(newF)
    }

    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Uint8ClampedArray
     */
    public sort(fn: (a: number, b: number) => number): Uint8ClampedArray {
        let arr: number[] = new number[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: number, b: number) => boolean =
                (a: number, b: number): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Uint8ClampedArray satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Uint8ClampedArray) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint8ClampedArray satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8ClampedArray) => boolean =
            (element: number, index: int, array: Uint8ClampedArray): boolean => { return fn(element as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint8ClampedArray) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint8ClampedArray) => number): number {
        let acc = this.at(0) as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint8ClampedArray) => number, init: number): number {
        let acc = init as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint8ClampedArray) => number): number {
        let acc: number = this.at(this.length - 1) as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Uint8ClampedArray using fn(arr[i]) over all elements of current Uint8ClampedArray.
    *
    * @param fn a function to apply for each element of current Uint8ClampedArray
    *
    * @returns a new Uint8ClampedArray where for each element from current Uint8ClampedArray fn was applied
    */
    public map(fn: (val: number, index: number) => number): Uint8ClampedArray {
        let resBuf = new ArrayBuffer(this.length * Uint8ClampedArray.BYTES_PER_ELEMENT)
        let res = new Uint8ClampedArray(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as number, i as double as number) as number)
        }
        return res
    }

    /**
     * Checks that all elements of Uint8ClampedArray satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Uint8ClampedArray) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint8ClampedArray satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8ClampedArray) => boolean =
            (element: number, index: int, array: Uint8ClampedArray): boolean => { return fn(element as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint8ClampedArray from current Uint8ClampedArray based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8ClampedArray with elements from current Uint8ClampedArray that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Uint8ClampedArray) => boolean): Uint8ClampedArray {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint8ClampedArray.BYTES_PER_ELEMENT)
        let res = new Uint8ClampedArray(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint8ClampedArray from current Uint8ClampedArray based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8ClampedArray with elements from current Uint8ClampedArray that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Uint8ClampedArray {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Uint8ClampedArray) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint8ClampedArray.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Uint8ClampedArray) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Uint8ClampedArray) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint8ClampedArray.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Uint8ClampedArray) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Uint8ClampedArray that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => boolean =
            (val: number, index: int, array: Uint8ClampedArray): boolean => { return fn(val as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint8ClampedArray
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Uint8ClampedArray) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as number, i as double as number, this))
        }
        throw new Error("Uint8ClampedArray.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint8ClampedArray
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => number): void {
        let newF: (val: number, index: int, array: Uint8ClampedArray) => number =
            (val: number, index: int, array: Uint8ClampedArray): number => { return fn(val as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint8ClampedArray from array-like argument
     *
     * @param o array-like object to initialize Uint8ClampedArray
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint8ClampedArray
     */
    public from(o: Object, mapFn: (e: Object, index: number) => number): Uint8ClampedArray {
        throw new Error("Uint8ClampedArray.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: ArrayBuffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of number stored in Uint8ClampedArray */
    public readonly length: int

    /** String \"Uint8ClampedArray\" */
    public readonly name = "Uint8ClampedArray"
}

/**
 * JS Uint8Array API-compatible class
 */
export class Uint8Array
{
    public static readonly BYTES_PER_ELEMENT = 1

    /**
     * Creates an empty Uint8Array.
     */
    public constructor() {
        this.length = 0
        this.byteLength = 0
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(0)
    }

    /**
     * Creates an Uint8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint8Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Uint8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint8Array
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        if (buf.byteLength % Uint8Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 1 as Uint8Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Uint8Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 1 as Uint8Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Uint8Array.BYTES_PER_ELEMENT > buf.byteLength) {
            throw new RangeError("Range Error: attempt to create Uint8Array where length * Uint8Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.byteLength - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Uint8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Uint8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Uint8Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayBuffer)
    {
        this(buf, 0, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }

     /**
     * Creates an Uint8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int)
    {
        this.length = length
        this.byteLength = length * Uint8Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Uint8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Uint8Array.
     *
     * @param other data initializer
     */
    public constructor(other: Uint8Array) {
        this.buffer = other.buffer.slice(0, other.buffer.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    /* public */ internal at(index: int): number
    {
        throw new Error("not implemented")
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int, endPos: int): void
    {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint8Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint8Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint8Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint8Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    // TODO(ivan-tyulyandin): blocked by tuples implentation
    // public entries(): Iterator<[Int, Object]> {
    //     let ret: Entry<Int, Object> = new Entry<Int, Object>[this.length];
    //     for (let i: int = 0; i < this.length; i++) {
    //         ret[i] = new Entry<Int, Object>(i, this.at(i));
    //     }
    //     return new MapIterator<Int, Object>(ret);
    // }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8Array
     */
    public fill(value: number, start: number, end: number): Uint8Array {
        return this.fill(value as number, start as int, end as int)
    }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8Array
     */
    /* public */ internal fill(value: number, start: int, end: int): Uint8Array {
        throw new Error("not implemented")
    }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8Array
     */
    public fill(value: number, start: number): Uint8Array {
        return this.fill(value as number, start as int)
    }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8Array
     */
    /* public */ internal fill(value: number, start: int): Uint8Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Uint8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint8Array
     */
    public fill(value: number): Uint8Array {
        return this.fill(value as number, 0, this.length)
    }



    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as number)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    /* public */ internal set(insertPos: int, val: number): void {
        throw new Error("not implemented")
    }

    /**
     * Copies all elements of arr to the current Uint8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint8Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as number)
        }
    }

    /**
     * Copies all elements of arr to the current Uint8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    /* public */ internal set(arr: number[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint8Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }



    /**
     * Creates an Uint8Array from array-like argument
     *
     * @param o array-like object to initialize Uint8Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint8Array
     */
    public from(o: Object, mapFn: (e: Object) => number): Uint8Array {
        let newF: (e: Object, index: int) => number =
            (e: Object, index: int): number => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Uint8Array from array-like argument
     *
     * @param o array-like object to initialize Uint8Array
     *
     * @returns new Uint8Array
     */
    public from(o: Object): Uint8Array {
        throw new Error("Uint8Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Uint8Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint8Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as number, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Uint8Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint8Array, false otherwise
     */
    /* public */ internal includes(e: number, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }

    /**
     * Checks if specified argument is in Uint8Array
     *
     * @param e search element
     *
     * @returns true if e is in Uint8Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as number, 0)
    }



    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as number, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    /* public */ internal indexOf(e: number, fromIndex: int): int {
        throw new Error("not implemented")
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as number)
    }



    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Uint8Array
     *
     * @returns iterator over keys
     */
    public keys(): Iterator<Int> {
        throw new Error("not implemented")
        // let ret: Int[] = new Int[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = i;
        // }
        // return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as number, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    /* public */ internal lastIndexOf(val: number, fromIndex: int): int
    {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as number, this.length - 1)
    }



   /**
    * Creates a new Uint8Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint8Array from data
    */
    public of(data: Object[]): Uint8Array {
        throw new Error("Uint8Array.of: not implemented")
    }

    /**
     * Creates a new Uint8Array using reversed data from the current one
     *
     * @returns a new Uint8Array using reversed data from the current one
     */
    public reverse(): Uint8Array {
        let res = new Uint8Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Uint8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint8Array with elements of current Uint8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Uint8Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Uint8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint8Array with elements of current Uint8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    /* public */ internal slice(begin: int, end: int): Uint8Array
    {
        if (begin < -this.length) {
            begin = 0
        }
        if (begin < 0) {
            begin = this.length + begin
        }
        if (begin >= this.length) {
            return new Uint8Array(new ArrayBuffer(0))
        }

        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end = this.length + end
        }
        if (end >= this.length) {
            end = this.length
        }

        if (end < begin) {
            return new Uint8Array(new ArrayBuffer(0))
        }

        let len = end - begin
        let resBuf = new ArrayBuffer(len * Uint8Array.BYTES_PER_ELEMENT)
        let res = new Uint8Array(resBuf)
        for (let i = 0; i < len; ++i) {
            res.set(i, this.at(i + begin))
        }
        return res
    }

    /**
     * Creates a slice of current Uint8Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint8Array with elements of current Uint8Array[begin, this.length)
     */
    public slice(begin: number): Uint8Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Uint8Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint8Array with elements of current Uint8Array[begin, this.length)
     */
    /* public */ internal slice(begin: int): Uint8Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Uint8 with all elements.
     *
     * @returns a new Uint8Array with elements of current Uint8Array
     */
    public slice(): Uint8Array {
        return new Uint8Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Uint8Array
     */
    public sort(): Uint8Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => { throw new Error("not implemented") }
        return this.sort(newF)
    }

    /**
     * Creates a Uint8Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint8Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Uint8Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Uint8Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint8Array with the same underlying ArrayBuffer
     */
    /* public */ internal subarray(begin: int, end: int): Uint8Array {
        return new Uint8Array(this.buffer, begin * Uint8Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Uint8Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint8Array with the same ArrayBuffer
     */
    public subarray(begin: number): Uint8Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Uint8Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint8Array with the same ArrayBuffer
     */
    /* public */ internal subarray(begin: int): Uint8Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Uint8Array with the same ArrayBuffer
     *
     * @returns new Uint8Array with the same ArrayBuffer
     */
    public subarray(): Uint8Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Uint8Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint8Array.toLocaleString: not implemented")
    }

    /**
     * Converts Uint8Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint8Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint8Array {
        return new Uint8Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint8Array {
        return new Uint8Array(this).sort()
    }

    /**
     * Returns a string representation of the Uint8Array
     *
     * @returns a string representation of the Uint8Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): Iterator<Number> {
        throw new Error("not implemented")
        // const ret = new Number[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = this.at(i);
        // }
        // return new ValuesIterator<Number>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8Array with replaced value on index
     */
    public with(index: number, value: number): Uint8Array {
        return this.with(index as int, value as number)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint8Array with replaced value on index
     */
    /* public */ internal with(index: int, value: number): Uint8Array {
        let res = new Uint8Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of Uint8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int, array: Uint8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8Array) => boolean =
            (element: number, index: int, array: Uint8Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint8Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint8Array) => number): number {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint8Array) => number, init: number): number {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint8Array) => number): number {
        let acc: number = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Uint8Array using fn(arr[i]) over all elements of current Uint8Array.
    *
    * @param fn a function to apply for each element of current Uint8Array
    *
    * @returns a new Uint8Array where for each element from current Uint8Array fn was applied
    */
    public map(fn: (val: number, index: int) => number): Uint8Array {
        let resBuf = new ArrayBuffer(this.length * Uint8Array.BYTES_PER_ELEMENT)
        let res = new Uint8Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Uint8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int, array: Uint8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8Array) => boolean =
            (element: number, index: int, array: Uint8Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint8Array from current Uint8Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8Array with elements from current Uint8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint8Array) => boolean): Uint8Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint8Array.BYTES_PER_ELEMENT)
        let res = new Uint8Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint8Array from current Uint8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8Array with elements from current Uint8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int) => boolean): Uint8Array {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint8Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: int, array: Uint8Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint8Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int, array: Uint8Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint8Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint8Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Uint8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int, array: Uint8Array) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Uint8Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int) => number): void {
        let newF: (val: number, index: int, array: Uint8Array) => number =
            (val: number, index: int, array: Uint8Array): number => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint8Array from array-like argument
     *
     * @param o array-like object to initialize Uint8Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint8Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => number): Uint8Array {
        throw new Error("Uint8Array.from: not implemented")
    }
    /**
     * Checks that all elements of Uint8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8Array) => boolean =
            (element: number, index: int, array: Uint8Array): boolean => { return fn(element as number) }
        return this.every(newF)
    }
    /**
     * creates a new Uint8Array from current Uint8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8Array with elements from current Uint8Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Uint8Array {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => number): void {
        let newF: (val: number, index: int, array: Uint8Array) => number =
            (val: number, index: int, array: Uint8Array): number => { return fn(val as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Uint8Array using fn(arr[i]) over all elements of current Uint8Array
    *
    * @param fn a function to apply for each element of current Uint8Array
    *
    * @returns a new Uint8Array where for each element from current Uint8Array fn was applied
    */
    public map(fn: (val: number) => number): Uint8Array
    {
        let newF: (val: number, index: int) => number =
            (val: number, index: int): number => { return fn(val as number) as number }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Uint8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8Array) => boolean =
            (element: number, index: int, array: Uint8Array): boolean => { return fn(element as number) }
        return this.some(newF)
    }

    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Uint8Array
     */
    public sort(fn: (a: number, b: number) => number): Uint8Array {
        let arr: number[] = new number[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: number, b: number) => boolean =
                (a: number, b: number): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Uint8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Uint8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8Array) => boolean =
            (element: number, index: int, array: Uint8Array): boolean => { return fn(element as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint8Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint8Array) => number): number {
        let acc = this.at(0) as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint8Array) => number, init: number): number {
        let acc = init as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint8Array) => number): number {
        let acc: number = this.at(this.length - 1) as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Uint8Array using fn(arr[i]) over all elements of current Uint8Array.
    *
    * @param fn a function to apply for each element of current Uint8Array
    *
    * @returns a new Uint8Array where for each element from current Uint8Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Uint8Array {
        let resBuf = new ArrayBuffer(this.length * Uint8Array.BYTES_PER_ELEMENT)
        let res = new Uint8Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as number, i as double as number) as number)
        }
        return res
    }

    /**
     * Checks that all elements of Uint8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Uint8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint8Array) => boolean =
            (element: number, index: int, array: Uint8Array): boolean => { return fn(element as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint8Array from current Uint8Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8Array with elements from current Uint8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Uint8Array) => boolean): Uint8Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint8Array.BYTES_PER_ELEMENT)
        let res = new Uint8Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint8Array from current Uint8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint8Array with elements from current Uint8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Uint8Array {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint8Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Uint8Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint8Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Uint8Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Uint8Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Uint8Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Uint8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint8Array) => boolean =
            (val: number, index: int, array: Uint8Array): boolean => { return fn(val as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Uint8Array) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as number, i as double as number, this))
        }
        throw new Error("Uint8Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => number): void {
        let newF: (val: number, index: int, array: Uint8Array) => number =
            (val: number, index: int, array: Uint8Array): number => { return fn(val as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint8Array from array-like argument
     *
     * @param o array-like object to initialize Uint8Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint8Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => number): Uint8Array {
        throw new Error("Uint8Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: ArrayBuffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of number stored in Uint8Array */
    public readonly length: int

    /** String \"Uint8Array\" */
    public readonly name = "Uint8Array"
}

/**
 * JS Uint16Array API-compatible class
 */
export class Uint16Array
{
    public static readonly BYTES_PER_ELEMENT = 2

    /**
     * Creates an empty Uint16Array.
     */
    public constructor() {
        this.length = 0
        this.byteLength = 0
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(0)
    }

    /**
     * Creates an Uint16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint16Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Uint16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint16Array
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        if (buf.byteLength % Uint16Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 2 as Uint16Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Uint16Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 2 as Uint16Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Uint16Array.BYTES_PER_ELEMENT > buf.byteLength) {
            throw new RangeError("Range Error: attempt to create Uint16Array where length * Uint16Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.byteLength - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Uint16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, byteOffset, buf.byteLength / Uint16Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Uint16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Uint16Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayBuffer)
    {
        this(buf, 0, buf.byteLength / Uint16Array.BYTES_PER_ELEMENT)
    }

     /**
     * Creates an Uint16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int)
    {
        this.length = length
        this.byteLength = length * Uint16Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Uint16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Uint16Array.
     *
     * @param other data initializer
     */
    public constructor(other: Uint16Array) {
        this.buffer = other.buffer.slice(0, other.buffer.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    /* public */ internal at(index: int): number
    {
        throw new Error("not implemented")
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int, endPos: int): void
    {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint16Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint16Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint16Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint16Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    // TODO(ivan-tyulyandin): blocked by tuples implentation
    // public entries(): Iterator<[Int, Object]> {
    //     let ret: Entry<Int, Object> = new Entry<Int, Object>[this.length];
    //     for (let i: int = 0; i < this.length; i++) {
    //         ret[i] = new Entry<Int, Object>(i, this.at(i));
    //     }
    //     return new MapIterator<Int, Object>(ret);
    // }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint16Array
     */
    public fill(value: number, start: number, end: number): Uint16Array {
        return this.fill(value as number, start as int, end as int)
    }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint16Array
     */
    /* public */ internal fill(value: number, start: int, end: int): Uint16Array {
        throw new Error("not implemented")
    }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint16Array
     */
    public fill(value: number, start: number): Uint16Array {
        return this.fill(value as number, start as int)
    }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint16Array
     */
    /* public */ internal fill(value: number, start: int): Uint16Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Uint16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint16Array
     */
    public fill(value: number): Uint16Array {
        return this.fill(value as number, 0, this.length)
    }



    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as number)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    /* public */ internal set(insertPos: int, val: number): void {
        throw new Error("not implemented")
    }

    /**
     * Copies all elements of arr to the current Uint16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint16Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as number)
        }
    }

    /**
     * Copies all elements of arr to the current Uint16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    /* public */ internal set(arr: number[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint16Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }



    /**
     * Creates an Uint16Array from array-like argument
     *
     * @param o array-like object to initialize Uint16Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint16Array
     */
    public from(o: Object, mapFn: (e: Object) => number): Uint16Array {
        let newF: (e: Object, index: int) => number =
            (e: Object, index: int): number => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Uint16Array from array-like argument
     *
     * @param o array-like object to initialize Uint16Array
     *
     * @returns new Uint16Array
     */
    public from(o: Object): Uint16Array {
        throw new Error("Uint16Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Uint16Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint16Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as number, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Uint16Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint16Array, false otherwise
     */
    /* public */ internal includes(e: number, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }

    /**
     * Checks if specified argument is in Uint16Array
     *
     * @param e search element
     *
     * @returns true if e is in Uint16Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as number, 0)
    }



    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as number, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    /* public */ internal indexOf(e: number, fromIndex: int): int {
        throw new Error("not implemented")
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as number)
    }



    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Uint16Array
     *
     * @returns iterator over keys
     */
    public keys(): Iterator<Int> {
        throw new Error("not implemented")
        // let ret: Int[] = new Int[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = i;
        // }
        // return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as number, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    /* public */ internal lastIndexOf(val: number, fromIndex: int): int
    {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as number, this.length - 1)
    }



   /**
    * Creates a new Uint16Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint16Array from data
    */
    public of(data: Object[]): Uint16Array {
        throw new Error("Uint16Array.of: not implemented")
    }

    /**
     * Creates a new Uint16Array using reversed data from the current one
     *
     * @returns a new Uint16Array using reversed data from the current one
     */
    public reverse(): Uint16Array {
        let res = new Uint16Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Uint16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint16Array with elements of current Uint16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Uint16Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Uint16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint16Array with elements of current Uint16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    /* public */ internal slice(begin: int, end: int): Uint16Array
    {
        if (begin < -this.length) {
            begin = 0
        }
        if (begin < 0) {
            begin = this.length + begin
        }
        if (begin >= this.length) {
            return new Uint16Array(new ArrayBuffer(0))
        }

        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end = this.length + end
        }
        if (end >= this.length) {
            end = this.length
        }

        if (end < begin) {
            return new Uint16Array(new ArrayBuffer(0))
        }

        let len = end - begin
        let resBuf = new ArrayBuffer(len * Uint16Array.BYTES_PER_ELEMENT)
        let res = new Uint16Array(resBuf)
        for (let i = 0; i < len; ++i) {
            res.set(i, this.at(i + begin))
        }
        return res
    }

    /**
     * Creates a slice of current Uint16Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint16Array with elements of current Uint16Array[begin, this.length)
     */
    public slice(begin: number): Uint16Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Uint16Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint16Array with elements of current Uint16Array[begin, this.length)
     */
    /* public */ internal slice(begin: int): Uint16Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Uint16 with all elements.
     *
     * @returns a new Uint16Array with elements of current Uint16Array
     */
    public slice(): Uint16Array {
        return new Uint16Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Uint16Array
     */
    public sort(): Uint16Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => { throw new Error("not implemented") }
        return this.sort(newF)
    }

    /**
     * Creates a Uint16Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint16Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Uint16Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Uint16Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint16Array with the same underlying ArrayBuffer
     */
    /* public */ internal subarray(begin: int, end: int): Uint16Array {
        return new Uint16Array(this.buffer, begin * Uint16Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Uint16Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint16Array with the same ArrayBuffer
     */
    public subarray(begin: number): Uint16Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Uint16Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint16Array with the same ArrayBuffer
     */
    /* public */ internal subarray(begin: int): Uint16Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Uint16Array with the same ArrayBuffer
     *
     * @returns new Uint16Array with the same ArrayBuffer
     */
    public subarray(): Uint16Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Uint16Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint16Array.toLocaleString: not implemented")
    }

    /**
     * Converts Uint16Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint16Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint16Array {
        return new Uint16Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint16Array {
        return new Uint16Array(this).sort()
    }

    /**
     * Returns a string representation of the Uint16Array
     *
     * @returns a string representation of the Uint16Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): Iterator<Number> {
        throw new Error("not implemented")
        // const ret = new Number[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = this.at(i);
        // }
        // return new ValuesIterator<Number>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint16Array with replaced value on index
     */
    public with(index: number, value: number): Uint16Array {
        return this.with(index as int, value as number)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint16Array with replaced value on index
     */
    /* public */ internal with(index: int, value: number): Uint16Array {
        let res = new Uint16Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of Uint16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int, array: Uint16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint16Array) => boolean =
            (element: number, index: int, array: Uint16Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint16Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint16Array) => number): number {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint16Array) => number, init: number): number {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint16Array) => number): number {
        let acc: number = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Uint16Array using fn(arr[i]) over all elements of current Uint16Array.
    *
    * @param fn a function to apply for each element of current Uint16Array
    *
    * @returns a new Uint16Array where for each element from current Uint16Array fn was applied
    */
    public map(fn: (val: number, index: int) => number): Uint16Array {
        let resBuf = new ArrayBuffer(this.length * Uint16Array.BYTES_PER_ELEMENT)
        let res = new Uint16Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Uint16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int, array: Uint16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint16Array) => boolean =
            (element: number, index: int, array: Uint16Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint16Array from current Uint16Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint16Array with elements from current Uint16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint16Array) => boolean): Uint16Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint16Array.BYTES_PER_ELEMENT)
        let res = new Uint16Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint16Array from current Uint16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint16Array with elements from current Uint16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int) => boolean): Uint16Array {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint16Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: int, array: Uint16Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint16Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int, array: Uint16Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint16Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint16Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Uint16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int, array: Uint16Array) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Uint16Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int) => number): void {
        let newF: (val: number, index: int, array: Uint16Array) => number =
            (val: number, index: int, array: Uint16Array): number => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint16Array from array-like argument
     *
     * @param o array-like object to initialize Uint16Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint16Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => number): Uint16Array {
        throw new Error("Uint16Array.from: not implemented")
    }
    /**
     * Checks that all elements of Uint16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint16Array) => boolean =
            (element: number, index: int, array: Uint16Array): boolean => { return fn(element as number) }
        return this.every(newF)
    }
    /**
     * creates a new Uint16Array from current Uint16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint16Array with elements from current Uint16Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Uint16Array {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => number): void {
        let newF: (val: number, index: int, array: Uint16Array) => number =
            (val: number, index: int, array: Uint16Array): number => { return fn(val as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Uint16Array using fn(arr[i]) over all elements of current Uint16Array
    *
    * @param fn a function to apply for each element of current Uint16Array
    *
    * @returns a new Uint16Array where for each element from current Uint16Array fn was applied
    */
    public map(fn: (val: number) => number): Uint16Array
    {
        let newF: (val: number, index: int) => number =
            (val: number, index: int): number => { return fn(val as number) as number }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Uint16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint16Array) => boolean =
            (element: number, index: int, array: Uint16Array): boolean => { return fn(element as number) }
        return this.some(newF)
    }

    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Uint16Array
     */
    public sort(fn: (a: number, b: number) => number): Uint16Array {
        let arr: number[] = new number[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: number, b: number) => boolean =
                (a: number, b: number): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Uint16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Uint16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint16Array) => boolean =
            (element: number, index: int, array: Uint16Array): boolean => { return fn(element as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint16Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint16Array) => number): number {
        let acc = this.at(0) as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint16Array) => number, init: number): number {
        let acc = init as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint16Array) => number): number {
        let acc: number = this.at(this.length - 1) as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Uint16Array using fn(arr[i]) over all elements of current Uint16Array.
    *
    * @param fn a function to apply for each element of current Uint16Array
    *
    * @returns a new Uint16Array where for each element from current Uint16Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Uint16Array {
        let resBuf = new ArrayBuffer(this.length * Uint16Array.BYTES_PER_ELEMENT)
        let res = new Uint16Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as number, i as double as number) as number)
        }
        return res
    }

    /**
     * Checks that all elements of Uint16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Uint16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint16Array) => boolean =
            (element: number, index: int, array: Uint16Array): boolean => { return fn(element as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint16Array from current Uint16Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint16Array with elements from current Uint16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Uint16Array) => boolean): Uint16Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint16Array.BYTES_PER_ELEMENT)
        let res = new Uint16Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint16Array from current Uint16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint16Array with elements from current Uint16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Uint16Array {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint16Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Uint16Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint16Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Uint16Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Uint16Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Uint16Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Uint16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint16Array) => boolean =
            (val: number, index: int, array: Uint16Array): boolean => { return fn(val as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Uint16Array) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as number, i as double as number, this))
        }
        throw new Error("Uint16Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => number): void {
        let newF: (val: number, index: int, array: Uint16Array) => number =
            (val: number, index: int, array: Uint16Array): number => { return fn(val as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint16Array from array-like argument
     *
     * @param o array-like object to initialize Uint16Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint16Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => number): Uint16Array {
        throw new Error("Uint16Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: ArrayBuffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of number stored in Uint16Array */
    public readonly length: int

    /** String \"Uint16Array\" */
    public readonly name = "Uint16Array"
}

/**
 * JS Uint32Array API-compatible class
 */
export class Uint32Array
{
    public static readonly BYTES_PER_ELEMENT = 4

    /**
     * Creates an empty Uint32Array.
     */
    public constructor() {
        this.length = 0
        this.byteLength = 0
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(0)
    }

    /**
     * Creates an Uint32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint32Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Uint32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type number in newly created Uint32Array
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        if (buf.byteLength % Uint32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 4 as Uint32Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Uint32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Uint32Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Uint32Array.BYTES_PER_ELEMENT > buf.byteLength) {
            throw new RangeError("Range Error: attempt to create Uint32Array where length * Uint32Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.byteLength - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Uint32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, byteOffset, buf.byteLength / Uint32Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Uint32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Uint32Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayBuffer)
    {
        this(buf, 0, buf.byteLength / Uint32Array.BYTES_PER_ELEMENT)
    }

     /**
     * Creates an Uint32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int)
    {
        this.length = length
        this.byteLength = length * Uint32Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Uint32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Uint32Array.
     *
     * @param other data initializer
     */
    public constructor(other: Uint32Array) {
        this.buffer = other.buffer.slice(0, other.buffer.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    /* public */ internal at(index: int): number
    {
        throw new Error("not implemented")
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int, endPos: int): void
    {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint32Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Uint32Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint32Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Uint32Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    // TODO(ivan-tyulyandin): blocked by tuples implentation
    // public entries(): Iterator<[Int, Object]> {
    //     let ret: Entry<Int, Object> = new Entry<Int, Object>[this.length];
    //     for (let i: int = 0; i < this.length; i++) {
    //         ret[i] = new Entry<Int, Object>(i, this.at(i));
    //     }
    //     return new MapIterator<Int, Object>(ret);
    // }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint32Array
     */
    public fill(value: number, start: number, end: number): Uint32Array {
        return this.fill(value as number, start as int, end as int)
    }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint32Array
     */
    /* public */ internal fill(value: number, start: int, end: int): Uint32Array {
        throw new Error("not implemented")
    }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint32Array
     */
    public fill(value: number, start: number): Uint32Array {
        return this.fill(value as number, start as int)
    }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint32Array
     */
    /* public */ internal fill(value: number, start: int): Uint32Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Uint32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Uint32Array
     */
    public fill(value: number): Uint32Array {
        return this.fill(value as number, 0, this.length)
    }



    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as number)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(number[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    /* public */ internal set(insertPos: int, val: number): void {
        throw new Error("not implemented")
    }

    /**
     * Copies all elements of arr to the current Uint32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint32Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as number)
        }
    }

    /**
     * Copies all elements of arr to the current Uint32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    /* public */ internal set(arr: number[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: number[]): size of arr is greater than Uint32Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current Uint32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }



    /**
     * Creates an Uint32Array from array-like argument
     *
     * @param o array-like object to initialize Uint32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint32Array
     */
    public from(o: Object, mapFn: (e: Object) => number): Uint32Array {
        let newF: (e: Object, index: int) => number =
            (e: Object, index: int): number => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Uint32Array from array-like argument
     *
     * @param o array-like object to initialize Uint32Array
     *
     * @returns new Uint32Array
     */
    public from(o: Object): Uint32Array {
        throw new Error("Uint32Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Uint32Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint32Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as number, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Uint32Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Uint32Array, false otherwise
     */
    /* public */ internal includes(e: number, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }

    /**
     * Checks if specified argument is in Uint32Array
     *
     * @param e search element
     *
     * @returns true if e is in Uint32Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as number, 0)
    }



    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as number, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    /* public */ internal indexOf(e: number, fromIndex: int): int {
        throw new Error("not implemented")
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as number)
    }



    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Uint32Array
     *
     * @returns iterator over keys
     */
    public keys(): Iterator<Int> {
        throw new Error("not implemented")
        // let ret: Int[] = new Int[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = i;
        // }
        // return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as number, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    /* public */ internal lastIndexOf(val: number, fromIndex: int): int
    {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as number, this.length - 1)
    }



   /**
    * Creates a new Uint32Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Uint32Array from data
    */
    public of(data: Object[]): Uint32Array {
        throw new Error("Uint32Array.of: not implemented")
    }

    /**
     * Creates a new Uint32Array using reversed data from the current one
     *
     * @returns a new Uint32Array using reversed data from the current one
     */
    public reverse(): Uint32Array {
        let res = new Uint32Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Uint32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint32Array with elements of current Uint32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): Uint32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Uint32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Uint32Array with elements of current Uint32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    /* public */ internal slice(begin: int, end: int): Uint32Array
    {
        if (begin < -this.length) {
            begin = 0
        }
        if (begin < 0) {
            begin = this.length + begin
        }
        if (begin >= this.length) {
            return new Uint32Array(new ArrayBuffer(0))
        }

        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end = this.length + end
        }
        if (end >= this.length) {
            end = this.length
        }

        if (end < begin) {
            return new Uint32Array(new ArrayBuffer(0))
        }

        let len = end - begin
        let resBuf = new ArrayBuffer(len * Uint32Array.BYTES_PER_ELEMENT)
        let res = new Uint32Array(resBuf)
        for (let i = 0; i < len; ++i) {
            res.set(i, this.at(i + begin))
        }
        return res
    }

    /**
     * Creates a slice of current Uint32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint32Array with elements of current Uint32Array[begin, this.length)
     */
    public slice(begin: number): Uint32Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Uint32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Uint32Array with elements of current Uint32Array[begin, this.length)
     */
    /* public */ internal slice(begin: int): Uint32Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Uint32 with all elements.
     *
     * @returns a new Uint32Array with elements of current Uint32Array
     */
    public slice(): Uint32Array {
        return new Uint32Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Uint32Array
     */
    public sort(): Uint32Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => { throw new Error("not implemented") }
        return this.sort(newF)
    }

    /**
     * Creates a Uint32Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint32Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Uint32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Uint32Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Uint32Array with the same underlying ArrayBuffer
     */
    /* public */ internal subarray(begin: int, end: int): Uint32Array {
        return new Uint32Array(this.buffer, begin * Uint32Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Uint32Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint32Array with the same ArrayBuffer
     */
    public subarray(begin: number): Uint32Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Uint32Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Uint32Array with the same ArrayBuffer
     */
    /* public */ internal subarray(begin: int): Uint32Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Uint32Array with the same ArrayBuffer
     *
     * @returns new Uint32Array with the same ArrayBuffer
     */
    public subarray(): Uint32Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Uint32Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Uint32Array.toLocaleString: not implemented")
    }

    /**
     * Converts Uint32Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Uint32Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Uint32Array {
        return new Uint32Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Uint32Array {
        return new Uint32Array(this).sort()
    }

    /**
     * Returns a string representation of the Uint32Array
     *
     * @returns a string representation of the Uint32Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): Iterator<Number> {
        throw new Error("not implemented")
        // const ret = new Number[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = this.at(i);
        // }
        // return new ValuesIterator<Number>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint32Array with replaced value on index
     */
    public with(index: number, value: number): Uint32Array {
        return this.with(index as int, value as number)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Uint32Array with replaced value on index
     */
    /* public */ internal with(index: int, value: number): Uint32Array {
        let res = new Uint32Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of Uint32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int, array: Uint32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint32Array) => boolean =
            (element: number, index: int, array: Uint32Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint32Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: int, array: Uint32Array) => number): number {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint32Array) => number, init: number): number {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: int, array: Uint32Array) => number): number {
        let acc: number = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Uint32Array using fn(arr[i]) over all elements of current Uint32Array.
    *
    * @param fn a function to apply for each element of current Uint32Array
    *
    * @returns a new Uint32Array where for each element from current Uint32Array fn was applied
    */
    public map(fn: (val: number, index: int) => number): Uint32Array {
        let resBuf = new ArrayBuffer(this.length * Uint32Array.BYTES_PER_ELEMENT)
        let res = new Uint32Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Uint32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int, array: Uint32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: int) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint32Array) => boolean =
            (element: number, index: int, array: Uint32Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint32Array from current Uint32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint32Array with elements from current Uint32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int, array: Uint32Array) => boolean): Uint32Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint32Array.BYTES_PER_ELEMENT)
        let res = new Uint32Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint32Array from current Uint32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint32Array with elements from current Uint32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: int) => boolean): Uint32Array {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint32Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: int, array: Uint32Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint32Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int, array: Uint32Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int, array: Uint32Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Uint32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: int) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int, array: Uint32Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: int) => boolean): int {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Uint32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int, array: Uint32Array) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Uint32Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: int) => number): void {
        let newF: (val: number, index: int, array: Uint32Array) => number =
            (val: number, index: int, array: Uint32Array): number => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint32Array from array-like argument
     *
     * @param o array-like object to initialize Uint32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint32Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => number): Uint32Array {
        throw new Error("Uint32Array.from: not implemented")
    }
    /**
     * Checks that all elements of Uint32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint32Array) => boolean =
            (element: number, index: int, array: Uint32Array): boolean => { return fn(element as number) }
        return this.every(newF)
    }
    /**
     * creates a new Uint32Array from current Uint32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint32Array with elements from current Uint32Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Uint32Array {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number) }
        return this.findLast(newF) as number
    }

    /**
     * Finds an index of the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => number): void {
        let newF: (val: number, index: int, array: Uint32Array) => number =
            (val: number, index: int, array: Uint32Array): number => { return fn(val as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Uint32Array using fn(arr[i]) over all elements of current Uint32Array
    *
    * @param fn a function to apply for each element of current Uint32Array
    *
    * @returns a new Uint32Array where for each element from current Uint32Array fn was applied
    */
    public map(fn: (val: number) => number): Uint32Array
    {
        let newF: (val: number, index: int) => number =
            (val: number, index: int): number => { return fn(val as number) as number }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Uint32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint32Array) => boolean =
            (element: number, index: int, array: Uint32Array): boolean => { return fn(element as number) }
        return this.some(newF)
    }

    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Uint32Array
     */
    public sort(fn: (a: number, b: number) => number): Uint32Array {
        let arr: number[] = new number[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: number, b: number) => boolean =
                (a: number, b: number): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Uint32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Uint32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Uint32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint32Array) => boolean =
            (element: number, index: int, array: Uint32Array): boolean => { return fn(element as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint32Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Uint32Array) => number): number {
        let acc = this.at(0) as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint32Array) => number, init: number): number {
        let acc = init as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Uint32Array) => number): number {
        let acc: number = this.at(this.length - 1) as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Uint32Array using fn(arr[i]) over all elements of current Uint32Array.
    *
    * @param fn a function to apply for each element of current Uint32Array
    *
    * @returns a new Uint32Array where for each element from current Uint32Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Uint32Array {
        let resBuf = new ArrayBuffer(this.length * Uint32Array.BYTES_PER_ELEMENT)
        let res = new Uint32Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as number, i as double as number) as number)
        }
        return res
    }

    /**
     * Checks that all elements of Uint32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Uint32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Uint32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: number, index: int, array: Uint32Array) => boolean =
            (element: number, index: int, array: Uint32Array): boolean => { return fn(element as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Uint32Array from current Uint32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint32Array with elements from current Uint32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Uint32Array) => boolean): Uint32Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Uint32Array.BYTES_PER_ELEMENT)
        let res = new Uint32Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Uint32Array from current Uint32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Uint32Array with elements from current Uint32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Uint32Array {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Uint32Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return number | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Uint32Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint32Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Uint32Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Uint32Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Uint32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Uint32Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Uint32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: number, index: int, array: Uint32Array) => boolean =
            (val: number, index: int, array: Uint32Array): boolean => { return fn(val as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Uint32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Uint32Array) => number): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as number, i as double as number, this))
        }
        throw new Error("Uint32Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Uint32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => number): void {
        let newF: (val: number, index: int, array: Uint32Array) => number =
            (val: number, index: int, array: Uint32Array): number => { return fn(val as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Uint32Array from array-like argument
     *
     * @param o array-like object to initialize Uint32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Uint32Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => number): Uint32Array {
        throw new Error("Uint32Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: ArrayBuffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of number stored in Uint32Array */
    public readonly length: int

    /** String \"Uint32Array\" */
    public readonly name = "Uint32Array"
}

/**
 * JS BigUint64Array API-compatible class
 */
export class BigUint64Array
{
    public static readonly BYTES_PER_ELEMENT = 8

    /**
     * Creates an empty BigUint64Array.
     */
    public constructor() {
        this.length = 0
        this.byteLength = 0
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(0)
    }

    /**
     * Creates an BigUint64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type BigInt in newly created BigUint64Array
     */
    public constructor(buf: ArrayBuffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an BigUint64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type BigInt in newly created BigUint64Array
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int, length: int) {
        if (buf.byteLength % BigUint64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 8 as BigUint64Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % BigUint64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as BigUint64Array.BYTES_PER_ELEMENT")
        }

        if (this.length * BigUint64Array.BYTES_PER_ELEMENT > buf.byteLength) {
            throw new RangeError("Range Error: attempt to create BigUint64Array where length * BigUint64Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.byteLength - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an BigUint64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    /* public */ internal constructor(buf: ArrayBuffer, byteOffset: int) {
        this(buf, byteOffset, buf.byteLength / BigUint64Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an BigUint64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: ArrayBuffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an BigUint64Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: ArrayBuffer)
    {
        this(buf, 0, buf.byteLength / BigUint64Array.BYTES_PER_ELEMENT)
    }

     /**
     * Creates an BigUint64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int)
    {
        this.length = length
        this.byteLength = length * BigUint64Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an BigUint64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of BigUint64Array.
     *
     * @param other data initializer
     */
    public constructor(other: BigUint64Array) {
        this.buffer = other.buffer.slice(0, other.buffer.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): BigInt {
        return new BigInt(this.at(index as int))
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    /* public */ internal at(index: int): BigInt
    {
        throw new Error("not implemented")
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int, endPos: int): void
    {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of BigUint64Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of BigUint64Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of BigUint64Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of BigUint64Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    /* public */ internal copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    // TODO(ivan-tyulyandin): blocked by tuples implentation
    // public entries(): Iterator<[Int, Object]> {
    //     let ret: Entry<Int, Object> = new Entry<Int, Object>[this.length];
    //     for (let i: int = 0; i < this.length; i++) {
    //         ret[i] = new Entry<Int, Object>(i, this.at(i));
    //     }
    //     return new MapIterator<Int, Object>(ret);
    // }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigUint64Array
     */
    public fill(value: BigInt, start: number, end: number): BigUint64Array {
        return this.fill(value, start as int, end as int)
    }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigUint64Array
     */
    /* public */ internal fill(value: BigInt, start: int, end: int): BigUint64Array {
        throw new Error("not implemented")
    }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigUint64Array
     */
    public fill(value: BigInt, start: number): BigUint64Array {
        return this.fill(new BigInt(value), start as int)
    }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigUint64Array
     */
    /* public */ internal fill(value: BigInt, start: int): BigUint64Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the BigUint64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigUint64Array
     */
    public fill(value: BigInt): BigUint64Array {
        return this.fill(value, 0, this.length)
    }



    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(BigInt[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: BigInt): void {
        this.set(insertPos as int, val)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(BigInt[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    /* public */ internal set(insertPos: int, val: BigInt): void {
        throw new Error("not implemented")
    }

    /**
     * Copies all elements of arr to the current BigUint64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: BigInt[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: BigInt[]): size of arr is greater than BigUint64Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current BigUint64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    /* public */ internal set(arr: BigInt[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: BigInt[]): size of arr is greater than BigUint64Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }

    /**
     * Copies all elements of arr to the current BigUint64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: BigInt[]): void {
        this.set(arr, 0)
    }



    /**
     * Creates an BigUint64Array from array-like argument
     *
     * @param o array-like object to initialize BigUint64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new BigUint64Array
     */
    public from(o: Object, mapFn: (e: Object) => BigInt): BigUint64Array {
        let newF: (e: Object, index: int) => BigInt =
            (e: Object, index: int): BigInt => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an BigUint64Array from array-like argument
     *
     * @param o array-like object to initialize BigUint64Array
     *
     * @returns new BigUint64Array
     */
    public from(o: Object): BigUint64Array {
        throw new Error("BigUint64Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in BigUint64Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in BigUint64Array, false otherwise
     */
    public includes(e: BigInt, fromIndex: number): boolean {
        return this.includes(e, fromIndex as int)
    }

    /**
     * Checks if specified argument is in BigUint64Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in BigUint64Array, false otherwise
     */
    /* public */ internal includes(e: BigInt, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }

    /**
     * Checks if specified argument is in BigUint64Array
     *
     * @param e search element
     *
     * @returns true if e is in BigUint64Array, false otherwise
     */
    public includes(e: BigInt): boolean {
        return this.includes(new BigInt(e), 0)
    }



    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: BigInt, fromIndex: number): number {
        return this.indexOf(e, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    /* public */ internal indexOf(e: BigInt, fromIndex: int): int {
        throw new Error("not implemented")
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: BigInt): number {
        return this.indexOf(e)
    }



    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the BigUint64Array
     *
     * @returns iterator over keys
     */
    public keys(): Iterator<Int> {
        throw new Error("not implemented")
        // let ret: Int[] = new Int[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = i;
        // }
        // return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: BigInt, fromIndex: number): number {
        return this.lastIndexOf(val, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    /* public */ internal lastIndexOf(val: BigInt, fromIndex: int): int
    {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: BigInt): number {
        return this.lastIndexOf(new BigInt(val), this.length - 1)
    }



   /**
    * Creates a new BigUint64Array using initializer
    *
    * @param data initializer
    *
    * @returns a new BigUint64Array from data
    */
    public of(data: Object[]): BigUint64Array {
        throw new Error("BigUint64Array.of: not implemented")
    }

    /**
     * Creates a new BigUint64Array using reversed data from the current one
     *
     * @returns a new BigUint64Array using reversed data from the current one
     */
    public reverse(): BigUint64Array {
        let res = new BigUint64Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current BigUint64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: number, end: number): BigUint64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current BigUint64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    /* public */ internal slice(begin: int, end: int): BigUint64Array
    {
        if (begin < -this.length) {
            begin = 0
        }
        if (begin < 0) {
            begin = this.length + begin
        }
        if (begin >= this.length) {
            return new BigUint64Array(new ArrayBuffer(0))
        }

        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end = this.length + end
        }
        if (end >= this.length) {
            end = this.length
        }

        if (end < begin) {
            return new BigUint64Array(new ArrayBuffer(0))
        }

        let len = end - begin
        let resBuf = new ArrayBuffer(len * BigUint64Array.BYTES_PER_ELEMENT)
        let res = new BigUint64Array(resBuf)
        for (let i = 0; i < len; ++i) {
            res.set(i, this.at(i + begin))
        }
        return res
    }

    /**
     * Creates a slice of current BigUint64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array[begin, this.length)
     */
    public slice(begin: number): BigUint64Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current BigUint64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array[begin, this.length)
     */
    /* public */ internal slice(begin: int): BigUint64Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current BigUint64 with all elements.
     *
     * @returns a new BigUint64Array with elements of current BigUint64Array
     */
    public slice(): BigUint64Array {
        return new BigUint64Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted BigUint64Array
     */
    public sort(): BigUint64Array {
        let newF: (a: BigInt, b: BigInt) => number = (a: BigInt, b: BigInt): number => { throw new Error("not implemented") }
        return this.sort(newF)
    }

    /**
     * Creates a BigUint64Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigUint64Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): BigUint64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a BigUint64Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigUint64Array with the same underlying ArrayBuffer
     */
    /* public */ internal subarray(begin: int, end: int): BigUint64Array {
        return new BigUint64Array(this.buffer, begin * BigUint64Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a BigUint64Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new BigUint64Array with the same ArrayBuffer
     */
    public subarray(begin: number): BigUint64Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a BigUint64Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new BigUint64Array with the same ArrayBuffer
     */
    /* public */ internal subarray(begin: int): BigUint64Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a BigUint64Array with the same ArrayBuffer
     *
     * @returns new BigUint64Array with the same ArrayBuffer
     */
    public subarray(): BigUint64Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts BigUint64Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("BigUint64Array.toLocaleString: not implemented")
    }

    /**
     * Converts BigUint64Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts BigUint64Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): BigUint64Array {
        return new BigUint64Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): BigUint64Array {
        return new BigUint64Array(this).sort()
    }

    /**
     * Returns a string representation of the BigUint64Array
     *
     * @returns a string representation of the BigUint64Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): Iterator<BigInt> {
        throw new Error("not implemented")
        // const ret = new BigInt[this.length];
        // for (let i: int = 0; i < this.length; i++) {
        //     ret[i] = this.at(i);
        // }
        // return new ValuesIterator<BigInt>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigUint64Array with replaced value on index
     */
    public with(index: number, value: BigInt): BigUint64Array {
        return this.with(index as int, value)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigUint64Array with replaced value on index
     */
    /* public */ internal with(index: int, value: BigInt): BigUint64Array {
        let res = new BigUint64Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of BigUint64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt, index: int, array: BigUint64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of BigUint64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt, index: int) => boolean): boolean {
        let newF: (element: BigInt, index: int, array: BigUint64Array) => boolean =
            (element: BigInt, index: int, array: BigUint64Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: BigInt, curVal: BigInt, curIndex: int, array: BigUint64Array) => BigInt, init: BigInt): BigInt {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: BigInt, curVal: BigInt, curIndex: int, array: BigUint64Array) => BigInt): BigInt {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: BigInt, curVal: BigInt, curIndex: int, array: BigUint64Array) => BigInt, init: BigInt): BigInt {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: BigInt, curVal: BigInt, curIndex: int, array: BigUint64Array) => BigInt): BigInt {
        let acc: BigInt = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new BigUint64Array using fn(arr[i]) over all elements of current BigUint64Array.
    *
    * @param fn a function to apply for each element of current BigUint64Array
    *
    * @returns a new BigUint64Array where for each element from current BigUint64Array fn was applied
    */
    public map(fn: (val: BigInt, index: int) => BigInt): BigUint64Array {
        let resBuf = new ArrayBuffer(this.length * BigUint64Array.BYTES_PER_ELEMENT)
        let res = new BigUint64Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of BigUint64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt, index: int, array: BigUint64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of BigUint64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt, index: int) => boolean): boolean {
        let newF: (element: BigInt, index: int, array: BigUint64Array) => boolean =
            (element: BigInt, index: int, array: BigUint64Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new BigUint64Array from current BigUint64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigUint64Array with elements from current BigUint64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): BigUint64Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * BigUint64Array.BYTES_PER_ELEMENT)
        let res = new BigUint64Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new BigUint64Array from current BigUint64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigUint64Array with elements from current BigUint64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: int) => boolean): BigUint64Array {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return BigInt | undefined as in JS
     */
    public find(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): BigInt {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("BigUint64Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: BigInt, index: int) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt, index: int) => boolean): int {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): BigInt {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("BigUint64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: int) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: int, array: BigUint64Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: int) => boolean): int {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of BigUint64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt, index: int, array: BigUint64Array) => BigInt): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("BigUint64Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of BigUint64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt, index: int) => BigInt): void {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => BigInt =
            (val: BigInt, index: int, array: BigUint64Array): BigInt => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an BigUint64Array from array-like argument
     *
     * @param o array-like object to initialize BigUint64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new BigUint64Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => BigInt): BigUint64Array {
        throw new Error("BigUint64Array.from: not implemented")
    }
    /**
     * Checks that all elements of BigUint64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt) => boolean): boolean {
        let newF: (element: BigInt, index: int, array: BigUint64Array) => boolean =
            (element: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(element)) }
        return this.every(newF)
    }
    /**
     * creates a new BigUint64Array from current BigUint64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigUint64Array with elements from current BigUint64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt) => boolean): BigUint64Array {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val)) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: BigInt) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val)) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt) => boolean): number {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val)) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val)) }
        return new BigInt(this.findLast(newF))
    }

    /**
     * Finds an index of the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt) => boolean): number {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val)) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of BigUint64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt) => BigInt): void {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => BigInt =
            (val: BigInt, index: int, array: BigUint64Array): BigInt => { return fn(new BigInt(val)) }
        this.forEach(newF)
    }

   /**
    * Creates a new BigUint64Array using fn(arr[i]) over all elements of current BigUint64Array
    *
    * @param fn a function to apply for each element of current BigUint64Array
    *
    * @returns a new BigUint64Array where for each element from current BigUint64Array fn was applied
    */
    public map(fn: (val: BigInt) => BigInt): BigUint64Array
    {
        let newF: (val: BigInt, index: int) => BigInt =
            (val: BigInt, index: int): BigInt => { return fn(new BigInt(val)) }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of BigUint64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt) => boolean): boolean {
        let newF: (element: BigInt, index: int, array: BigUint64Array) => boolean =
            (element: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(element)) }
        return this.some(newF)
    }

    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted BigUint64Array
     */
    public sort(fn: (a: BigInt, b: BigInt) => number): BigUint64Array {
        let arr: BigInt[] = new BigInt[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: BigInt, b: BigInt) => boolean =
                (a: BigInt, b: BigInt): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of BigUint64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt, index: number, array: BigUint64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(new BigInt(this.at(i)), i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of BigUint64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt, index: number) => boolean): boolean {
        let newF: (element: BigInt, index: int, array: BigUint64Array) => boolean =
            (element: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(element), index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigUint64Array) => BigInt, init: BigInt): BigInt {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigUint64Array) => BigInt): BigInt {
        let acc = new BigInt(this.at(0))
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigUint64Array) => BigInt, init: BigInt): BigInt {
        let acc = new BigInt(init)
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigUint64Array) => BigInt): BigInt {
        let acc: BigInt = new BigInt(this.at(this.length - 1))
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new BigUint64Array using fn(arr[i]) over all elements of current BigUint64Array.
    *
    * @param fn a function to apply for each element of current BigUint64Array
    *
    * @returns a new BigUint64Array where for each element from current BigUint64Array fn was applied
    */
    public map(fn: (val: BigInt, index: number) => BigInt): BigUint64Array {
        let resBuf = new ArrayBuffer(this.length * BigUint64Array.BYTES_PER_ELEMENT)
        let res = new BigUint64Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(new BigInt(this.at(i)), i as double as number))
        }
        return res
    }

    /**
     * Checks that all elements of BigUint64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt, index: number, array: BigUint64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(new BigInt(this.at(i)), i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of BigUint64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt, index: number) => boolean): boolean {
        let newF: (element: BigInt, index: int, array: BigUint64Array) => boolean =
            (element: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(element), index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new BigUint64Array from current BigUint64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigUint64Array with elements from current BigUint64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: number, array: BigUint64Array) => boolean): BigUint64Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(new BigInt(this.at(i)), i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * BigUint64Array.BYTES_PER_ELEMENT)
        let res = new BigUint64Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new BigUint64Array from current BigUint64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigUint64Array with elements from current BigUint64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: number) => boolean): BigUint64Array {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return BigInt | undefined as in JS
     */
    public find(fn: (val: BigInt, index: number, array: BigUint64Array) => boolean): BigInt {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return val
            }
        }
        throw new Error("BigUint64Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: BigInt, index: number) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt, index: number, array: BigUint64Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt, index: number) => boolean): number {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: number, array: BigUint64Array) => boolean): BigInt {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return val
            }
        }
        throw new Error("BigUint64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: number) => boolean): BigInt {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: number, array: BigUint64Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the BigUint64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: number) => boolean): number {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => boolean =
            (val: BigInt, index: int, array: BigUint64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of BigUint64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt, index: number, array: BigUint64Array) => BigInt): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(new BigInt(this.at(i)), i as double as number, this))
        }
        throw new Error("BigUint64Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of BigUint64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt, index: number) => BigInt): void {
        let newF: (val: BigInt, index: int, array: BigUint64Array) => BigInt =
            (val: BigInt, index: int, array: BigUint64Array): BigInt => { return fn(new BigInt(val), index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an BigUint64Array from array-like argument
     *
     * @param o array-like object to initialize BigUint64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new BigUint64Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => BigInt): BigUint64Array {
        throw new Error("BigUint64Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: ArrayBuffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of BigInt stored in BigUint64Array */
    public readonly length: int

    /** String \"BigUint64Array\" */
    public readonly name = "BigUint64Array"
}
