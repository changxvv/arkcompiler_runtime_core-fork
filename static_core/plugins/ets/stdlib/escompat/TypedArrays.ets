/*
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file. DO NOT EDIT

package escompat;

/**
 * JS Int8Array API-compatible class
 */
export final class Int8Array {
    public static readonly BYTES_PER_ELEMENT = 1

    /**
     * Creates an empty Int8Array.
     */
    public constructor() {
        this(new ArrayBuffer(0), 0, 0)
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: Buffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Int8Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type byte in newly created Int8Array
     */
    public constructor(buf: Buffer, byteOffset: int, length: int) {
        if (buf.getByteLength() % Int8Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 1 as Int8Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Int8Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 1 as Int8Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Int8Array.BYTES_PER_ELEMENT > buf.getByteLength()) {
            throw new RangeError("Range Error: attempt to create Int8Array where length * Int8Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.getByteLength() - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Int8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: int) {
        this(buf, byteOffset, buf.getByteLength() / Int8Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Int8Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Int8Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: Buffer) {
        this(buf, 0, buf.getByteLength() / Int8Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Int8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this.length = length
        this.byteLength = length * Int8Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Int8Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Int8Array.
     *
     * @param other data initializer
     */
    public constructor(other: Int8Array) {
        this.buffer = other.buffer.sliceInternal(0, other.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as double as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): byte {
        if (index < 0) {
            index = this.length + index
        }
        let byteIndex = index * Int8Array.BYTES_PER_ELEMENT + this.byteOffset
        let res: byte = 0
        for (let i = 0; i < Int8Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = this.buffer.at(byteIndex + i) as byte
            res = (res | byteVal << (8 * i)) as byte;
        }
        return res
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: int, startPos: int, endPos: int): void {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Int8Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Int8Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Int8Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Int8Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    /* public */ internal entries(): MapIterator<Int, Byte> {
        let ret: Entry<Int, Byte>[] = new Entry<Int, Byte>[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = new Entry<Int, Byte>(i, this.at(i));
        }
        return new MapIterator<Int, Byte>(ret);
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start: number, end: number): Int8Array {
        return this.fill(value as double as int as byte, start as int, end as int)
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start: int, end: int): Int8Array {
        if (start < -this.length) {
            start = 0
        }
        if (start < 0) {
            start += this.length
        }
        if (start >= this.length) {
            return this;
        }
        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end += this.length
        }
        if (end >= this.length) {
            end = this.length
        }
        for (let i = start; i < end; ++i) {
            this.set(i, value)
        }
        return this;
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: number, start: number): Int8Array {
        return this.fill(value as double as int as byte, start as int)
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte, start: int): Int8Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Int8Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int8Array
     */
    public fill(value: byte): Int8Array {
        return this.fill(value, 0, this.length)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(byte[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as double as int as byte)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(byte[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: byte): void {
        if (insertPos < 0 || insertPos >= this.length) {
            throw new RangeError("set: insertPos is out-of-bounds")
        }

        let startByte = insertPos * Int8Array.BYTES_PER_ELEMENT + this.byteOffset
        let bits = val;
        for (let i = 0; i < Int8Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
            this.buffer.set(startByte + i, byteVal)
        }
    }

    /**
     * Copies all elements of arr to the current Int8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: byte[]): size of arr is greater than Int8Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as double as int as byte)
        }
    }

    /**
     * Copies all elements of arr to the current Int8Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: byte[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: byte[]): size of arr is greater than Int8Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }


    /**
     * Copies all elements of arr to the current Int8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int8Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: byte[]): void {
        this.set(arr, 0)
    }

    /**
     * Creates an Int8Array from array-like argument
     *
     * @param o array-like object to initialize Int8Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int8Array
     */
    public from(o: Object, mapFn: (e: Object) => byte): Int8Array {
        let newF: (e: Object, index: int) => byte =
            (e: Object, index: int): byte => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Int8Array from array-like argument
     *
     * @param o array-like object to initialize Int8Array
     *
     * @returns new Int8Array
     */
    public from(o: Object): Int8Array {
        throw new Error("Int8Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Int8Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Int8Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as double as int as byte, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Int8Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Int8Array, false otherwise
     */
    public includes(e: byte, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }


    /**
     * Checks if specified argument is in Int8Array
     *
     * @param e search element
     *
     * @returns true if e is in Int8Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as double as int as byte, 0)
    }

    /**
     * Checks if specified argument is in Int8Array
     *
     * @param e search element
     *
     * @returns true if e is in Int8Array, false otherwise
     */
    public includes(e: byte): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as double as int as byte, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: byte, fromIndex: int): int {
        if (fromIndex >= this.length) {
            return -1
        }
        if (fromIndex < 0) {
            fromIndex += this.length
            // See TypedArray.indexOf JS docs
            if (fromIndex < 0) {
                fromIndex = 0
            }
        }
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return i
            }
        }
        return -1
    }


    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as double as int as byte)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: byte): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Int8Array
     *
     * @returns iterator over keys
     */
    public keys(): ValuesIterator<Int> {
        let ret: Int[] = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = i;
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as double as int as byte, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: byte, fromIndex: int): int {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }


    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as double as int as byte, this.length - 1)
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: byte): int {
        return this.lastIndexOf(val, this.length - 1)
    }

   /**
    * Creates a new Int8Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Int8Array from data
    */
    public of(data: Object[]): Int8Array {
        throw new Error("Int8Array.of: not implemented")
    }

    /**
     * Creates a new Int8Array using reversed data from the current one
     *
     * @returns a new Int8Array using reversed data from the current one
     */
    public reverse(): Int8Array {
        let res = new Int8Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
     public slice(begin: number, end: number): Int8Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Int8Array {
        let buf = this.buffer.sliceInternal(begin * Int8Array.BYTES_PER_ELEMENT, end * Int8Array.BYTES_PER_ELEMENT)
        return new Int8Array(buf)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin, this.length)
     */
    public slice(begin: number): Int8Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Int8Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int8Array with elements of current Int8Array[begin, this.length)
     */
    public slice(begin: int): Int8Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Int8 with all elements.
     *
     * @returns a new Int8Array with elements of current Int8Array
     */
    public slice(): Int8Array {
        return new Int8Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Int8Array
     */
    public sort(): Int8Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => {
            const a1 = a as double as int as byte
            const b1 = b as double as int as byte
            return a1 < b1 ? -1 : a1 == b1 ? 0 : 1
        }
        return this.sort(newF)
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Int8Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int8Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int8Array with the same underlying ArrayBuffer
     */
    public subarray(begin: int, end: int): Int8Array {
        return new Int8Array(this.buffer, begin * Int8Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Int8Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Int8Array with the same ArrayBuffer
     */
    public subarray(begin: number): Int8Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Int8Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Int8Array with the same ArrayBuffer
     */
    public subarray(begin: int): Int8Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Int8Array with the same ArrayBuffer
     *
     * @returns new Int8Array with the same ArrayBuffer
     */
    public subarray(): Int8Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Int8Array.toLocaleString: not implemented")
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Int8Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Int8Array {
        return new Int8Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Int8Array {
        return new Int8Array(this).sort()
    }

    /**
     * Returns a string representation of the Int8Array
     *
     * @returns a string representation of the Int8Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): ValuesIterator<Byte> {
        const ret = new Byte[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = this.at(i);
        }
        return new ValuesIterator<Byte>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int8Array with replaced value on index
     */
    public with(index: number, value: number): Int8Array {
        return this.with(index as int, value as double as int as byte)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int8Array with replaced value on index
     */
    public with(index: int, value: byte): Int8Array {
        let res = new Int8Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Checks that all elements of Int8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: byte) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element) }
        return this.every(newF)
    }
    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: byte) => boolean): Int8Array {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: byte) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: byte) => boolean): int {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: byte) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: byte) => boolean): int {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Int8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: byte) => byte): void {
        let newF: (val: byte, index: int, array: Int8Array) => byte =
            (val: byte, index: int, array: Int8Array): byte => { return fn(val) }
        this.forEach(newF)
    }

   /**
    * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array
    *
    * @param fn a function to apply for each element of current Int8Array
    *
    * @returns a new Int8Array where for each element from current Int8Array fn was applied
    */
    public map(fn: (val: byte) => byte): Int8Array {
        let newF: (val: byte, index: int) => byte =
            (val: byte, index: int): byte => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Int8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: byte) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Int8Array
     */
    public sort(fn: (a: byte, b: byte) => int): Int8Array {
        let arr: byte[] = new byte[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: byte, b: byte) => boolean =
                (a: byte, b: byte): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Int8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: byte, index: int, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Int8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: byte, index: int) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: byte, curVal: byte, curIndex: int, array: Int8Array) => byte, init: byte): byte {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: byte, curVal: byte, curIndex: int, array: Int8Array) => byte): byte {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: byte, curVal: byte, curIndex: int, array: Int8Array) => byte, init: byte): byte {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: byte, curVal: byte, curIndex: int, array: Int8Array) => byte): byte {
        let acc: byte = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array.
    *
    * @param fn a function to apply for each element of current Int8Array
    *
    * @returns a new Int8Array where for each element from current Int8Array fn was applied
    */
    public map(fn: (val: byte, index: int) => byte): Int8Array {
        let resBuf = new ArrayBuffer(this.length * Int8Array.BYTES_PER_ELEMENT)
        let res = new Int8Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Int8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: byte, index: int, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Int8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: byte, index: int) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Int8Array from current Int8Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: byte, index: int, array: Int8Array) => boolean): Int8Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int8Array.BYTES_PER_ELEMENT)
        let res = new Int8Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: byte, index: int) => boolean): Int8Array {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int8Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return byte | undefined as in JS
     */
    public find(fn: (val: byte, index: int, array: Int8Array) => boolean): byte {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Int8Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: byte, index: int) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: byte, index: int, array: Int8Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: byte, index: int) => boolean): int {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: byte, index: int, array: Int8Array) => boolean): byte {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Int8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: byte, index: int) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: byte, index: int, array: Int8Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: byte, index: int) => boolean): int {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Int8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: byte, index: int, array: Int8Array) => byte): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Int8Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Int8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: byte, index: int) => byte): void {
        let newF: (val: byte, index: int, array: Int8Array) => byte =
            (val: byte, index: int, array: Int8Array): byte => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Int8Array from array-like argument
     *
     * @param o array-like object to initialize Int8Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int8Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => byte): Int8Array {
        throw new Error("Int8Array.from: not implemented")
    }
    /**
     * Checks that all elements of Int8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element as double as number) }
        return this.every(newF)
    }
    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Int8Array {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number) }
        return this.findLast(newF) as double as number
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Int8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => byte): void {
        let newF: (val: byte, index: int, array: Int8Array) => byte =
            (val: byte, index: int, array: Int8Array): byte => { return fn(val as double as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array
    *
    * @param fn a function to apply for each element of current Int8Array
    *
    * @returns a new Int8Array where for each element from current Int8Array fn was applied
    */
    public map(fn: (val: number) => number): Int8Array {
        let newF: (val: byte, index: int) => byte =
            (val: byte, index: int): byte => { return fn(val as double as number) as double as int as byte }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Int8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element as double as number) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Int8Array
     */
    public sort(fn: (a: number, b: number) => number): Int8Array {
        let arr: byte[] = new byte[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: byte, b: byte) => boolean =
                (a: byte, b: byte): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Int8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as double as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Int8Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Int8Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Int8Array) => number): number {
        let acc = this.at(0) as double as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Int8Array) => number, init: number): number {
        let acc = init as double as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Int8Array) => number): number {
        let acc: number = this.at(this.length - 1) as double as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Int8Array using fn(arr[i]) over all elements of current Int8Array.
    *
    * @param fn a function to apply for each element of current Int8Array
    *
    * @returns a new Int8Array where for each element from current Int8Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Int8Array {
        let resBuf = new ArrayBuffer(this.length * Int8Array.BYTES_PER_ELEMENT)
        let res = new Int8Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as double as number, i as double as number) as double as int as byte)
        }
        return res
    }

    /**
     * Checks that all elements of Int8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Int8Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as double as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Int8Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: byte, index: int, array: Int8Array) => boolean =
            (element: byte, index: int, array: Int8Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Int8Array from current Int8Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Int8Array) => boolean): Int8Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as double as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int8Array.BYTES_PER_ELEMENT)
        let res = new Int8Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int8Array from current Int8Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int8Array with elements from current Int8Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Int8Array {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int8Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return byte | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Int8Array) => boolean): byte {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Int8Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Int8Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Int8Array) => boolean): byte {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Int8Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): byte {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Int8Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Int8Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: byte, index: int, array: Int8Array) => boolean =
            (val: byte, index: int, array: Int8Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Int8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Int8Array) => byte): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as double as number, i as double as number, this))
        }
        throw new Error("Int8Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Int8Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => byte): void {
        let newF: (val: byte, index: int, array: Int8Array) => byte =
            (val: byte, index: int, array: Int8Array): byte => { return fn(val as double as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Int8Array from array-like argument
     *
     * @param o array-like object to initialize Int8Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int8Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => byte): Int8Array {
        throw new Error("Int8Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: Buffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of byte stored in Int8Array */
    public readonly length: int

    /** String \"Int8Array\" */
    public readonly name = "Int8Array"
}

/**
 * JS Int16Array API-compatible class
 */
export final class Int16Array {
    public static readonly BYTES_PER_ELEMENT = 2

    /**
     * Creates an empty Int16Array.
     */
    public constructor() {
        this(new ArrayBuffer(0), 0, 0)
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: Buffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Int16Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type short in newly created Int16Array
     */
    public constructor(buf: Buffer, byteOffset: int, length: int) {
        if (buf.getByteLength() % Int16Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Int16Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 2 as Int16Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Int16Array.BYTES_PER_ELEMENT > buf.getByteLength()) {
            throw new RangeError("Range Error: attempt to create Int16Array where length * Int16Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.getByteLength() - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Int16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: int) {
        this(buf, byteOffset, buf.getByteLength() / Int16Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Int16Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Int16Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: Buffer) {
        this(buf, 0, buf.getByteLength() / Int16Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Int16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this.length = length
        this.byteLength = length * Int16Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Int16Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Int16Array.
     *
     * @param other data initializer
     */
    public constructor(other: Int16Array) {
        this.buffer = other.buffer.sliceInternal(0, other.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as double as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): short {
        if (index < 0) {
            index = this.length + index
        }
        let byteIndex = index * Int16Array.BYTES_PER_ELEMENT + this.byteOffset
        let res: short = 0
        for (let i = 0; i < Int16Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = this.buffer.at(byteIndex + i) as short
            byteVal &= 0xff
            res = (res | byteVal << (8 * i)) as short;
        }
        return res
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: int, startPos: int, endPos: int): void {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Int16Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Int16Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Int16Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Int16Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    /* public */ internal entries(): MapIterator<Int, Short> {
        let ret: Entry<Int, Short>[] = new Entry<Int, Short>[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = new Entry<Int, Short>(i, this.at(i));
        }
        return new MapIterator<Int, Short>(ret);
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start: number, end: number): Int16Array {
        return this.fill(value as double as int as short, start as int, end as int)
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start: int, end: int): Int16Array {
        if (start < -this.length) {
            start = 0
        }
        if (start < 0) {
            start += this.length
        }
        if (start >= this.length) {
            return this;
        }
        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end += this.length
        }
        if (end >= this.length) {
            end = this.length
        }
        for (let i = start; i < end; ++i) {
            this.set(i, value)
        }
        return this;
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: number, start: number): Int16Array {
        return this.fill(value as double as int as short, start as int)
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short, start: int): Int16Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Int16Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int16Array
     */
    public fill(value: short): Int16Array {
        return this.fill(value, 0, this.length)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(short[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as double as int as short)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(short[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: short): void {
        if (insertPos < 0 || insertPos >= this.length) {
            throw new RangeError("set: insertPos is out-of-bounds")
        }

        let startByte = insertPos * Int16Array.BYTES_PER_ELEMENT + this.byteOffset
        let bits = val;
        for (let i = 0; i < Int16Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
            this.buffer.set(startByte + i, byteVal)
        }
    }

    /**
     * Copies all elements of arr to the current Int16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: short[]): size of arr is greater than Int16Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as double as int as short)
        }
    }

    /**
     * Copies all elements of arr to the current Int16Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: short[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: short[]): size of arr is greater than Int16Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }


    /**
     * Copies all elements of arr to the current Int16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int16Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: short[]): void {
        this.set(arr, 0)
    }

    /**
     * Creates an Int16Array from array-like argument
     *
     * @param o array-like object to initialize Int16Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int16Array
     */
    public from(o: Object, mapFn: (e: Object) => short): Int16Array {
        let newF: (e: Object, index: int) => short =
            (e: Object, index: int): short => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Int16Array from array-like argument
     *
     * @param o array-like object to initialize Int16Array
     *
     * @returns new Int16Array
     */
    public from(o: Object): Int16Array {
        throw new Error("Int16Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Int16Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Int16Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as double as int as short, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Int16Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Int16Array, false otherwise
     */
    public includes(e: short, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }


    /**
     * Checks if specified argument is in Int16Array
     *
     * @param e search element
     *
     * @returns true if e is in Int16Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as double as int as short, 0)
    }

    /**
     * Checks if specified argument is in Int16Array
     *
     * @param e search element
     *
     * @returns true if e is in Int16Array, false otherwise
     */
    public includes(e: short): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as double as int as short, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: short, fromIndex: int): int {
        if (fromIndex >= this.length) {
            return -1
        }
        if (fromIndex < 0) {
            fromIndex += this.length
            // See TypedArray.indexOf JS docs
            if (fromIndex < 0) {
                fromIndex = 0
            }
        }
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return i
            }
        }
        return -1
    }


    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as double as int as short)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: short): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Int16Array
     *
     * @returns iterator over keys
     */
    public keys(): ValuesIterator<Int> {
        let ret: Int[] = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = i;
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as double as int as short, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: short, fromIndex: int): int {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }


    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as double as int as short, this.length - 1)
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: short): int {
        return this.lastIndexOf(val, this.length - 1)
    }

   /**
    * Creates a new Int16Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Int16Array from data
    */
    public of(data: Object[]): Int16Array {
        throw new Error("Int16Array.of: not implemented")
    }

    /**
     * Creates a new Int16Array using reversed data from the current one
     *
     * @returns a new Int16Array using reversed data from the current one
     */
    public reverse(): Int16Array {
        let res = new Int16Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
     public slice(begin: number, end: number): Int16Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Int16Array {
        let buf = this.buffer.sliceInternal(begin * Int16Array.BYTES_PER_ELEMENT, end * Int16Array.BYTES_PER_ELEMENT)
        return new Int16Array(buf)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin, this.length)
     */
    public slice(begin: number): Int16Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Int16Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int16Array with elements of current Int16Array[begin, this.length)
     */
    public slice(begin: int): Int16Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Int16 with all elements.
     *
     * @returns a new Int16Array with elements of current Int16Array
     */
    public slice(): Int16Array {
        return new Int16Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Int16Array
     */
    public sort(): Int16Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => {
            const a1 = a as double as int as short
            const b1 = b as double as int as short
            return a1 < b1 ? -1 : a1 == b1 ? 0 : 1
        }
        return this.sort(newF)
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Int16Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int16Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int16Array with the same underlying ArrayBuffer
     */
    public subarray(begin: int, end: int): Int16Array {
        return new Int16Array(this.buffer, begin * Int16Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Int16Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Int16Array with the same ArrayBuffer
     */
    public subarray(begin: number): Int16Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Int16Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Int16Array with the same ArrayBuffer
     */
    public subarray(begin: int): Int16Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Int16Array with the same ArrayBuffer
     *
     * @returns new Int16Array with the same ArrayBuffer
     */
    public subarray(): Int16Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Int16Array.toLocaleString: not implemented")
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Int16Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Int16Array {
        return new Int16Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Int16Array {
        return new Int16Array(this).sort()
    }

    /**
     * Returns a string representation of the Int16Array
     *
     * @returns a string representation of the Int16Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): ValuesIterator<Short> {
        const ret = new Short[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = this.at(i);
        }
        return new ValuesIterator<Short>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int16Array with replaced value on index
     */
    public with(index: number, value: number): Int16Array {
        return this.with(index as int, value as double as int as short)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int16Array with replaced value on index
     */
    public with(index: int, value: short): Int16Array {
        let res = new Int16Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Checks that all elements of Int16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: short) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element) }
        return this.every(newF)
    }
    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: short) => boolean): Int16Array {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: short) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: short) => boolean): int {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: short) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: short) => boolean): int {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Int16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: short) => short): void {
        let newF: (val: short, index: int, array: Int16Array) => short =
            (val: short, index: int, array: Int16Array): short => { return fn(val) }
        this.forEach(newF)
    }

   /**
    * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array
    *
    * @param fn a function to apply for each element of current Int16Array
    *
    * @returns a new Int16Array where for each element from current Int16Array fn was applied
    */
    public map(fn: (val: short) => short): Int16Array {
        let newF: (val: short, index: int) => short =
            (val: short, index: int): short => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Int16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: short) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Int16Array
     */
    public sort(fn: (a: short, b: short) => int): Int16Array {
        let arr: short[] = new short[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: short, b: short) => boolean =
                (a: short, b: short): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Int16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: short, index: int, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Int16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: short, index: int) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: short, curVal: short, curIndex: int, array: Int16Array) => short, init: short): short {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: short, curVal: short, curIndex: int, array: Int16Array) => short): short {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: short, curVal: short, curIndex: int, array: Int16Array) => short, init: short): short {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: short, curVal: short, curIndex: int, array: Int16Array) => short): short {
        let acc: short = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array.
    *
    * @param fn a function to apply for each element of current Int16Array
    *
    * @returns a new Int16Array where for each element from current Int16Array fn was applied
    */
    public map(fn: (val: short, index: int) => short): Int16Array {
        let resBuf = new ArrayBuffer(this.length * Int16Array.BYTES_PER_ELEMENT)
        let res = new Int16Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Int16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: short, index: int, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Int16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: short, index: int) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Int16Array from current Int16Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: short, index: int, array: Int16Array) => boolean): Int16Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int16Array.BYTES_PER_ELEMENT)
        let res = new Int16Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: short, index: int) => boolean): Int16Array {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int16Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return short | undefined as in JS
     */
    public find(fn: (val: short, index: int, array: Int16Array) => boolean): short {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Int16Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: short, index: int) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: short, index: int, array: Int16Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: short, index: int) => boolean): int {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: short, index: int, array: Int16Array) => boolean): short {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Int16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: short, index: int) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: short, index: int, array: Int16Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: short, index: int) => boolean): int {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Int16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: short, index: int, array: Int16Array) => short): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Int16Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Int16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: short, index: int) => short): void {
        let newF: (val: short, index: int, array: Int16Array) => short =
            (val: short, index: int, array: Int16Array): short => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Int16Array from array-like argument
     *
     * @param o array-like object to initialize Int16Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int16Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => short): Int16Array {
        throw new Error("Int16Array.from: not implemented")
    }
    /**
     * Checks that all elements of Int16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element as double as number) }
        return this.every(newF)
    }
    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Int16Array {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number) }
        return this.findLast(newF) as double as number
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Int16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => short): void {
        let newF: (val: short, index: int, array: Int16Array) => short =
            (val: short, index: int, array: Int16Array): short => { return fn(val as double as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array
    *
    * @param fn a function to apply for each element of current Int16Array
    *
    * @returns a new Int16Array where for each element from current Int16Array fn was applied
    */
    public map(fn: (val: number) => number): Int16Array {
        let newF: (val: short, index: int) => short =
            (val: short, index: int): short => { return fn(val as double as number) as double as int as short }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Int16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element as double as number) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Int16Array
     */
    public sort(fn: (a: number, b: number) => number): Int16Array {
        let arr: short[] = new short[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: short, b: short) => boolean =
                (a: short, b: short): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Int16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as double as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Int16Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Int16Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Int16Array) => number): number {
        let acc = this.at(0) as double as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Int16Array) => number, init: number): number {
        let acc = init as double as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Int16Array) => number): number {
        let acc: number = this.at(this.length - 1) as double as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Int16Array using fn(arr[i]) over all elements of current Int16Array.
    *
    * @param fn a function to apply for each element of current Int16Array
    *
    * @returns a new Int16Array where for each element from current Int16Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Int16Array {
        let resBuf = new ArrayBuffer(this.length * Int16Array.BYTES_PER_ELEMENT)
        let res = new Int16Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as double as number, i as double as number) as double as int as short)
        }
        return res
    }

    /**
     * Checks that all elements of Int16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Int16Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as double as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Int16Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: short, index: int, array: Int16Array) => boolean =
            (element: short, index: int, array: Int16Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Int16Array from current Int16Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Int16Array) => boolean): Int16Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as double as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int16Array.BYTES_PER_ELEMENT)
        let res = new Int16Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int16Array from current Int16Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int16Array with elements from current Int16Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Int16Array {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int16Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return short | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Int16Array) => boolean): short {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Int16Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Int16Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Int16Array) => boolean): short {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Int16Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): short {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Int16Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Int16Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: short, index: int, array: Int16Array) => boolean =
            (val: short, index: int, array: Int16Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Int16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Int16Array) => short): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as double as number, i as double as number, this))
        }
        throw new Error("Int16Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Int16Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => short): void {
        let newF: (val: short, index: int, array: Int16Array) => short =
            (val: short, index: int, array: Int16Array): short => { return fn(val as double as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Int16Array from array-like argument
     *
     * @param o array-like object to initialize Int16Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int16Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => short): Int16Array {
        throw new Error("Int16Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: Buffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of short stored in Int16Array */
    public readonly length: int

    /** String \"Int16Array\" */
    public readonly name = "Int16Array"
}

/**
 * JS Int32Array API-compatible class
 */
export final class Int32Array {
    public static readonly BYTES_PER_ELEMENT = 4

    /**
     * Creates an empty Int32Array.
     */
    public constructor() {
        this(new ArrayBuffer(0), 0, 0)
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: Buffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Int32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type int in newly created Int32Array
     */
    public constructor(buf: Buffer, byteOffset: int, length: int) {
        if (buf.getByteLength() % Int32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Int32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Int32Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Int32Array.BYTES_PER_ELEMENT > buf.getByteLength()) {
            throw new RangeError("Range Error: attempt to create Int32Array where length * Int32Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.getByteLength() - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Int32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: int) {
        this(buf, byteOffset, buf.getByteLength() / Int32Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Int32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Int32Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: Buffer) {
        this(buf, 0, buf.getByteLength() / Int32Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Int32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this.length = length
        this.byteLength = length * Int32Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Int32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Int32Array.
     *
     * @param other data initializer
     */
    public constructor(other: Int32Array) {
        this.buffer = other.buffer.sliceInternal(0, other.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as double as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): int {
        if (index < 0) {
            index = this.length + index
        }
        let byteIndex = index * Int32Array.BYTES_PER_ELEMENT + this.byteOffset
        let res: int = 0
        for (let i = 0; i < Int32Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = this.buffer.at(byteIndex + i) as int
            byteVal &= 0xff
            res = (res | byteVal << (8 * i)) as int;
        }
        return res
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: int, startPos: int, endPos: int): void {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Int32Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Int32Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Int32Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Int32Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    /* public */ internal entries(): MapIterator<Int, Int> {
        let ret: Entry<Int, Int>[] = new Entry<Int, Int>[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = new Entry<Int, Int>(i, this.at(i));
        }
        return new MapIterator<Int, Int>(ret);
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start: number, end: number): Int32Array {
        return this.fill(value as double as int as int, start as int, end as int)
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start: int, end: int): Int32Array {
        if (start < -this.length) {
            start = 0
        }
        if (start < 0) {
            start += this.length
        }
        if (start >= this.length) {
            return this;
        }
        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end += this.length
        }
        if (end >= this.length) {
            end = this.length
        }
        for (let i = start; i < end; ++i) {
            this.set(i, value)
        }
        return this;
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: number, start: number): Int32Array {
        return this.fill(value as double as int as int, start as int)
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int, start: int): Int32Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Int32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Int32Array
     */
    public fill(value: int): Int32Array {
        return this.fill(value, 0, this.length)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(int[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as double as int as int)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(int[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: int): void {
        if (insertPos < 0 || insertPos >= this.length) {
            throw new RangeError("set: insertPos is out-of-bounds")
        }

        let startByte = insertPos * Int32Array.BYTES_PER_ELEMENT + this.byteOffset
        let bits = val;
        for (let i = 0; i < Int32Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
            this.buffer.set(startByte + i, byteVal)
        }
    }

    /**
     * Copies all elements of arr to the current Int32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: int[]): size of arr is greater than Int32Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as double as int as int)
        }
    }

    /**
     * Copies all elements of arr to the current Int32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: int[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: int[]): size of arr is greater than Int32Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }


    /**
     * Copies all elements of arr to the current Int32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Int32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: int[]): void {
        this.set(arr, 0)
    }

    /**
     * Creates an Int32Array from array-like argument
     *
     * @param o array-like object to initialize Int32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int32Array
     */
    public from(o: Object, mapFn: (e: Object) => int): Int32Array {
        let newF: (e: Object, index: int) => int =
            (e: Object, index: int): int => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Int32Array from array-like argument
     *
     * @param o array-like object to initialize Int32Array
     *
     * @returns new Int32Array
     */
    public from(o: Object): Int32Array {
        throw new Error("Int32Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Int32Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Int32Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as double as int as int, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Int32Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Int32Array, false otherwise
     */
    public includes(e: int, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }


    /**
     * Checks if specified argument is in Int32Array
     *
     * @param e search element
     *
     * @returns true if e is in Int32Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as double as int as int, 0)
    }

    /**
     * Checks if specified argument is in Int32Array
     *
     * @param e search element
     *
     * @returns true if e is in Int32Array, false otherwise
     */
    public includes(e: int): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as double as int as int, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: int, fromIndex: int): int {
        if (fromIndex >= this.length) {
            return -1
        }
        if (fromIndex < 0) {
            fromIndex += this.length
            // See TypedArray.indexOf JS docs
            if (fromIndex < 0) {
                fromIndex = 0
            }
        }
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return i
            }
        }
        return -1
    }


    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as double as int as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: int): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Int32Array
     *
     * @returns iterator over keys
     */
    public keys(): ValuesIterator<Int> {
        let ret: Int[] = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = i;
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as double as int as int, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: int, fromIndex: int): int {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }


    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as double as int as int, this.length - 1)
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: int): int {
        return this.lastIndexOf(val, this.length - 1)
    }

   /**
    * Creates a new Int32Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Int32Array from data
    */
    public of(data: Object[]): Int32Array {
        throw new Error("Int32Array.of: not implemented")
    }

    /**
     * Creates a new Int32Array using reversed data from the current one
     *
     * @returns a new Int32Array using reversed data from the current one
     */
    public reverse(): Int32Array {
        let res = new Int32Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
     public slice(begin: number, end: number): Int32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Int32Array {
        let buf = this.buffer.sliceInternal(begin * Int32Array.BYTES_PER_ELEMENT, end * Int32Array.BYTES_PER_ELEMENT)
        return new Int32Array(buf)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin, this.length)
     */
    public slice(begin: number): Int32Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Int32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Int32Array with elements of current Int32Array[begin, this.length)
     */
    public slice(begin: int): Int32Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Int32 with all elements.
     *
     * @returns a new Int32Array with elements of current Int32Array
     */
    public slice(): Int32Array {
        return new Int32Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Int32Array
     */
    public sort(): Int32Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => {
            const a1 = a as double as int as int
            const b1 = b as double as int as int
            return a1 < b1 ? -1 : a1 == b1 ? 0 : 1
        }
        return this.sort(newF)
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Int32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Int32Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Int32Array with the same underlying ArrayBuffer
     */
    public subarray(begin: int, end: int): Int32Array {
        return new Int32Array(this.buffer, begin * Int32Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Int32Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Int32Array with the same ArrayBuffer
     */
    public subarray(begin: number): Int32Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Int32Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Int32Array with the same ArrayBuffer
     */
    public subarray(begin: int): Int32Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Int32Array with the same ArrayBuffer
     *
     * @returns new Int32Array with the same ArrayBuffer
     */
    public subarray(): Int32Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Int32Array.toLocaleString: not implemented")
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Int32Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Int32Array {
        return new Int32Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Int32Array {
        return new Int32Array(this).sort()
    }

    /**
     * Returns a string representation of the Int32Array
     *
     * @returns a string representation of the Int32Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): ValuesIterator<Int> {
        const ret = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = this.at(i);
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int32Array with replaced value on index
     */
    public with(index: number, value: number): Int32Array {
        return this.with(index as int, value as double as int as int)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Int32Array with replaced value on index
     */
    public with(index: int, value: int): Int32Array {
        let res = new Int32Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Checks that all elements of Int32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: int) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element) }
        return this.every(newF)
    }
    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: int) => boolean): Int32Array {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Int32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: int) => int): void {
        let newF: (val: int, index: int, array: Int32Array) => int =
            (val: int, index: int, array: Int32Array): int => { return fn(val) }
        this.forEach(newF)
    }

   /**
    * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array
    *
    * @param fn a function to apply for each element of current Int32Array
    *
    * @returns a new Int32Array where for each element from current Int32Array fn was applied
    */
    public map(fn: (val: int) => int): Int32Array {
        let newF: (val: int, index: int) => int =
            (val: int, index: int): int => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Int32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: int) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Int32Array
     */
    public sort(fn: (a: int, b: int) => int): Int32Array {
        let arr: int[] = new int[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: int, b: int) => boolean =
                (a: int, b: int): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Int32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: int, index: int, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Int32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: int, index: int) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: int, curVal: int, curIndex: int, array: Int32Array) => int, init: int): int {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: int, curVal: int, curIndex: int, array: Int32Array) => int): int {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: int, curVal: int, curIndex: int, array: Int32Array) => int, init: int): int {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: int, curVal: int, curIndex: int, array: Int32Array) => int): int {
        let acc: int = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array.
    *
    * @param fn a function to apply for each element of current Int32Array
    *
    * @returns a new Int32Array where for each element from current Int32Array fn was applied
    */
    public map(fn: (val: int, index: int) => int): Int32Array {
        let resBuf = new ArrayBuffer(this.length * Int32Array.BYTES_PER_ELEMENT)
        let res = new Int32Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Int32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: int, index: int, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Int32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: int, index: int) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Int32Array from current Int32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: int, index: int, array: Int32Array) => boolean): Int32Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int32Array.BYTES_PER_ELEMENT)
        let res = new Int32Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: int, index: int) => boolean): Int32Array {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int32Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return int | undefined as in JS
     */
    public find(fn: (val: int, index: int, array: Int32Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Int32Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: int, index: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: int, index: int, array: Int32Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: int, index: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: int, index: int, array: Int32Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Int32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: int, index: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: int, index: int, array: Int32Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: int, index: int) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Int32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: int, index: int, array: Int32Array) => int): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Int32Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Int32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: int, index: int) => int): void {
        let newF: (val: int, index: int, array: Int32Array) => int =
            (val: int, index: int, array: Int32Array): int => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Int32Array from array-like argument
     *
     * @param o array-like object to initialize Int32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int32Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => int): Int32Array {
        throw new Error("Int32Array.from: not implemented")
    }
    /**
     * Checks that all elements of Int32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element as double as number) }
        return this.every(newF)
    }
    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Int32Array {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number) }
        return this.findLast(newF) as double as number
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Int32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => int): void {
        let newF: (val: int, index: int, array: Int32Array) => int =
            (val: int, index: int, array: Int32Array): int => { return fn(val as double as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array
    *
    * @param fn a function to apply for each element of current Int32Array
    *
    * @returns a new Int32Array where for each element from current Int32Array fn was applied
    */
    public map(fn: (val: number) => number): Int32Array {
        let newF: (val: int, index: int) => int =
            (val: int, index: int): int => { return fn(val as double as number) as double as int as int }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Int32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element as double as number) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Int32Array
     */
    public sort(fn: (a: number, b: number) => number): Int32Array {
        let arr: int[] = new int[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: int, b: int) => boolean =
                (a: int, b: int): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Int32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as double as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Int32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Int32Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Int32Array) => number): number {
        let acc = this.at(0) as double as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Int32Array) => number, init: number): number {
        let acc = init as double as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Int32Array) => number): number {
        let acc: number = this.at(this.length - 1) as double as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Int32Array using fn(arr[i]) over all elements of current Int32Array.
    *
    * @param fn a function to apply for each element of current Int32Array
    *
    * @returns a new Int32Array where for each element from current Int32Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Int32Array {
        let resBuf = new ArrayBuffer(this.length * Int32Array.BYTES_PER_ELEMENT)
        let res = new Int32Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as double as number, i as double as number) as double as int as int)
        }
        return res
    }

    /**
     * Checks that all elements of Int32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Int32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as double as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Int32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: int, index: int, array: Int32Array) => boolean =
            (element: int, index: int, array: Int32Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Int32Array from current Int32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Int32Array) => boolean): Int32Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as double as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Int32Array.BYTES_PER_ELEMENT)
        let res = new Int32Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Int32Array from current Int32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Int32Array with elements from current Int32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Int32Array {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Int32Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return int | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Int32Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Int32Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Int32Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Int32Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Int32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): int {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Int32Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Int32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: int, index: int, array: Int32Array) => boolean =
            (val: int, index: int, array: Int32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Int32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Int32Array) => int): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as double as number, i as double as number, this))
        }
        throw new Error("Int32Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Int32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => int): void {
        let newF: (val: int, index: int, array: Int32Array) => int =
            (val: int, index: int, array: Int32Array): int => { return fn(val as double as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Int32Array from array-like argument
     *
     * @param o array-like object to initialize Int32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Int32Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => int): Int32Array {
        throw new Error("Int32Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: Buffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of int stored in Int32Array */
    public readonly length: int

    /** String \"Int32Array\" */
    public readonly name = "Int32Array"
}

/**
 * JS BigInt64Array API-compatible class
 */
export final class BigInt64Array {
    public static readonly BYTES_PER_ELEMENT = 8

    /**
     * Creates an empty BigInt64Array.
     */
    public constructor() {
        this(new ArrayBuffer(0), 0, 0)
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: Buffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an BigInt64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type long in newly created BigInt64Array
     */
    public constructor(buf: Buffer, byteOffset: int, length: int) {
        if (buf.getByteLength() % BigInt64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % BigInt64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as BigInt64Array.BYTES_PER_ELEMENT")
        }

        if (this.length * BigInt64Array.BYTES_PER_ELEMENT > buf.getByteLength()) {
            throw new RangeError("Range Error: attempt to create BigInt64Array where length * BigInt64Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.getByteLength() - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an BigInt64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: int) {
        this(buf, byteOffset, buf.getByteLength() / BigInt64Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an BigInt64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an BigInt64Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: Buffer) {
        this(buf, 0, buf.getByteLength() / BigInt64Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an BigInt64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this.length = length
        this.byteLength = length * BigInt64Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an BigInt64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of BigInt64Array.
     *
     * @param other data initializer
     */
    public constructor(other: BigInt64Array) {
        this.buffer = other.buffer.sliceInternal(0, other.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): BigInt {
        return new BigInt(this.at(index as int))
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): long {
        if (index < 0) {
            index = this.length + index
        }
        let byteIndex = index * BigInt64Array.BYTES_PER_ELEMENT + this.byteOffset
        let res: long = 0
        for (let i = 0; i < BigInt64Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = this.buffer.at(byteIndex + i) as long
            byteVal &= 0xff
            res = (res | byteVal << (8 * i)) as long;
        }
        return res
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: int, startPos: int, endPos: int): void {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of BigInt64Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of BigInt64Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of BigInt64Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of BigInt64Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    /* public */ internal entries(): MapIterator<Int, Long> {
        let ret: Entry<Int, Long>[] = new Entry<Int, Long>[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = new Entry<Int, Long>(i, this.at(i));
        }
        return new MapIterator<Int, Long>(ret);
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start: number, end: number): BigInt64Array {
        return this.fill(value.getLong(), start as int, end as int)
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start: int, end: int): BigInt64Array {
        if (start < -this.length) {
            start = 0
        }
        if (start < 0) {
            start += this.length
        }
        if (start >= this.length) {
            return this;
        }
        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end += this.length
        }
        if (end >= this.length) {
            end = this.length
        }
        for (let i = start; i < end; ++i) {
            this.set(i, value)
        }
        return this;
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: BigInt, start: number): BigInt64Array {
        return this.fill(value.getLong(), start as int)
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long, start: int): BigInt64Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the BigInt64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified BigInt64Array
     */
    public fill(value: long): BigInt64Array {
        return this.fill(value, 0, this.length)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(long[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: BigInt): void {
        this.set(insertPos as int, val.getLong())
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(long[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: long): void {
        if (insertPos < 0 || insertPos >= this.length) {
            throw new RangeError("set: insertPos is out-of-bounds")
        }

        let startByte = insertPos * BigInt64Array.BYTES_PER_ELEMENT + this.byteOffset
        let bits = val;
        for (let i = 0; i < BigInt64Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
            this.buffer.set(startByte + i, byteVal)
        }
    }

    /**
     * Copies all elements of arr to the current BigInt64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: BigInt[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: long[]): size of arr is greater than BigInt64Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i].getLong())
        }
    }

    /**
     * Copies all elements of arr to the current BigInt64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: long[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: long[]): size of arr is greater than BigInt64Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }


    /**
     * Copies all elements of arr to the current BigInt64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: BigInt[]): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current BigInt64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: long[]): void {
        this.set(arr, 0)
    }

    /**
     * Creates an BigInt64Array from array-like argument
     *
     * @param o array-like object to initialize BigInt64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new BigInt64Array
     */
    public from(o: Object, mapFn: (e: Object) => long): BigInt64Array {
        let newF: (e: Object, index: int) => long =
            (e: Object, index: int): long => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an BigInt64Array from array-like argument
     *
     * @param o array-like object to initialize BigInt64Array
     *
     * @returns new BigInt64Array
     */
    public from(o: Object): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in BigInt64Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in BigInt64Array, false otherwise
     */
    public includes(e: BigInt, fromIndex: number): boolean {
        return this.includes(e.getLong(), fromIndex as int)
    }

    /**
     * Checks if specified argument is in BigInt64Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in BigInt64Array, false otherwise
     */
    public includes(e: long, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }


    /**
     * Checks if specified argument is in BigInt64Array
     *
     * @param e search element
     *
     * @returns true if e is in BigInt64Array, false otherwise
     */
    public includes(e: BigInt): boolean {
        return this.includes(e.getLong(), 0)
    }

    /**
     * Checks if specified argument is in BigInt64Array
     *
     * @param e search element
     *
     * @returns true if e is in BigInt64Array, false otherwise
     */
    public includes(e: long): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: BigInt, fromIndex: number): number {
        return this.indexOf(e.getLong(), fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: long, fromIndex: int): int {
        if (fromIndex >= this.length) {
            return -1
        }
        if (fromIndex < 0) {
            fromIndex += this.length
            // See TypedArray.indexOf JS docs
            if (fromIndex < 0) {
                fromIndex = 0
            }
        }
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return i
            }
        }
        return -1
    }


    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: BigInt): number {
        return this.indexOf(e.getLong())
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: long): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the BigInt64Array
     *
     * @returns iterator over keys
     */
    public keys(): ValuesIterator<Int> {
        let ret: Int[] = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = i;
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: BigInt, fromIndex: number): number {
        return this.lastIndexOf(val.getLong(), fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: long, fromIndex: int): int {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }


    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: BigInt): number {
        return this.lastIndexOf(val.getLong(), this.length - 1)
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: long): int {
        return this.lastIndexOf(val, this.length - 1)
    }

   /**
    * Creates a new BigInt64Array using initializer
    *
    * @param data initializer
    *
    * @returns a new BigInt64Array from data
    */
    public of(data: Object[]): BigInt64Array {
        throw new Error("BigInt64Array.of: not implemented")
    }

    /**
     * Creates a new BigInt64Array using reversed data from the current one
     *
     * @returns a new BigInt64Array using reversed data from the current one
     */
    public reverse(): BigInt64Array {
        let res = new BigInt64Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
     public slice(begin: number, end: number): BigInt64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): BigInt64Array {
        let buf = this.buffer.sliceInternal(begin * BigInt64Array.BYTES_PER_ELEMENT, end * BigInt64Array.BYTES_PER_ELEMENT)
        return new BigInt64Array(buf)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin, this.length)
     */
    public slice(begin: number): BigInt64Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current BigInt64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array[begin, this.length)
     */
    public slice(begin: int): BigInt64Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current BigInt64 with all elements.
     *
     * @returns a new BigInt64Array with elements of current BigInt64Array
     */
    public slice(): BigInt64Array {
        return new BigInt64Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted BigInt64Array
     */
    public sort(): BigInt64Array {
        let newF: (a: BigInt, b: BigInt) => number = (a: BigInt, b: BigInt): number => {
            const a1 = a.getLong()
            const b1 = b.getLong()
            return a1 < b1 ? -1 : a1 == b1 ? 0 : 1
        }
        return this.sort(newF)
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): BigInt64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a BigInt64Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new BigInt64Array with the same underlying ArrayBuffer
     */
    public subarray(begin: int, end: int): BigInt64Array {
        return new BigInt64Array(this.buffer, begin * BigInt64Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a BigInt64Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new BigInt64Array with the same ArrayBuffer
     */
    public subarray(begin: number): BigInt64Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a BigInt64Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new BigInt64Array with the same ArrayBuffer
     */
    public subarray(begin: int): BigInt64Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a BigInt64Array with the same ArrayBuffer
     *
     * @returns new BigInt64Array with the same ArrayBuffer
     */
    public subarray(): BigInt64Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("BigInt64Array.toLocaleString: not implemented")
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts BigInt64Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): BigInt64Array {
        return new BigInt64Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): BigInt64Array {
        return new BigInt64Array(this).sort()
    }

    /**
     * Returns a string representation of the BigInt64Array
     *
     * @returns a string representation of the BigInt64Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): ValuesIterator<Long> {
        const ret = new Long[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = this.at(i);
        }
        return new ValuesIterator<Long>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigInt64Array with replaced value on index
     */
    public with(index: number, value: BigInt): BigInt64Array {
        return this.with(index as int, value.getLong())
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an BigInt64Array with replaced value on index
     */
    public with(index: int, value: long): BigInt64Array {
        let res = new BigInt64Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of BigInt64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: long, index: int, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of BigInt64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: long, index: int) => boolean): boolean {
        let newF: (element: long, index: int, array: BigInt64Array) => boolean =
            (element: long, index: int, array: BigInt64Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: long, curVal: long, curIndex: int, array: BigInt64Array) => long, init: long): long {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: long, curVal: long, curIndex: int, array: BigInt64Array) => long): long {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: long, curVal: long, curIndex: int, array: BigInt64Array) => long, init: long): long {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: long, curVal: long, curIndex: int, array: BigInt64Array) => long): long {
        let acc: long = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new BigInt64Array using fn(arr[i]) over all elements of current BigInt64Array.
    *
    * @param fn a function to apply for each element of current BigInt64Array
    *
    * @returns a new BigInt64Array where for each element from current BigInt64Array fn was applied
    */
    public map(fn: (val: long, index: int) => long): BigInt64Array {
        let resBuf = new ArrayBuffer(this.length * BigInt64Array.BYTES_PER_ELEMENT)
        let res = new BigInt64Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of BigInt64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: long, index: int, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of BigInt64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: long, index: int) => boolean): boolean {
        let newF: (element: long, index: int, array: BigInt64Array) => boolean =
            (element: long, index: int, array: BigInt64Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new BigInt64Array from current BigInt64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: long, index: int, array: BigInt64Array) => boolean): BigInt64Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * BigInt64Array.BYTES_PER_ELEMENT)
        let res = new BigInt64Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new BigInt64Array from current BigInt64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: long, index: int) => boolean): BigInt64Array {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return long | undefined as in JS
     */
    public find(fn: (val: long, index: int, array: BigInt64Array) => boolean): long {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("BigInt64Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: long, index: int) => boolean): long {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: long, index: int, array: BigInt64Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: long, index: int) => boolean): int {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: long, index: int, array: BigInt64Array) => boolean): long {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("BigInt64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: long, index: int) => boolean): long {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: long, index: int, array: BigInt64Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: long, index: int) => boolean): int {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of BigInt64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: long, index: int, array: BigInt64Array) => long): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("BigInt64Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of BigInt64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: long, index: int) => long): void {
        let newF: (val: long, index: int, array: BigInt64Array) => long =
            (val: long, index: int, array: BigInt64Array): long => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an BigInt64Array from array-like argument
     *
     * @param o array-like object to initialize BigInt64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new BigInt64Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => long): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }
    /**
     * Checks that all elements of BigInt64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt) => boolean): boolean {
        let newF: (element: long, index: int, array: BigInt64Array) => boolean =
            (element: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(element)) }
        return this.every(newF)
    }
    /**
     * creates a new BigInt64Array from current BigInt64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt) => boolean): BigInt64Array {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val)) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: BigInt) => boolean): long {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val)) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt) => boolean): number {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val)) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt) => boolean): BigInt {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val)) }
        return new BigInt(this.findLast(newF))
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt) => boolean): number {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val)) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of BigInt64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt) => long): void {
        let newF: (val: long, index: int, array: BigInt64Array) => long =
            (val: long, index: int, array: BigInt64Array): long => { return fn(new BigInt(val)) }
        this.forEach(newF)
    }

   /**
    * Creates a new BigInt64Array using fn(arr[i]) over all elements of current BigInt64Array
    *
    * @param fn a function to apply for each element of current BigInt64Array
    *
    * @returns a new BigInt64Array where for each element from current BigInt64Array fn was applied
    */
    public map(fn: (val: BigInt) => BigInt): BigInt64Array {
        let newF: (val: long, index: int) => long =
            (val: long, index: int): long => { return fn(new BigInt(val)).getLong() }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of BigInt64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt) => boolean): boolean {
        let newF: (element: long, index: int, array: BigInt64Array) => boolean =
            (element: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(element)) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted BigInt64Array
     */
    public sort(fn: (a: BigInt, b: BigInt) => number): BigInt64Array {
        let arr: long[] = new long[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: long, b: long) => boolean =
                (a: long, b: long): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of BigInt64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt, index: number, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(new BigInt(this.at(i)), i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of BigInt64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: BigInt, index: number) => boolean): boolean {
        let newF: (element: long, index: int, array: BigInt64Array) => boolean =
            (element: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(element), index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigInt64Array) => BigInt, init: BigInt): BigInt {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigInt64Array) => BigInt): BigInt {
        let acc = new BigInt(this.at(0))
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigInt64Array) => BigInt, init: BigInt): BigInt {
        let acc = new BigInt(init)
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: BigInt, curVal: BigInt, curIndex: number, array: BigInt64Array) => BigInt): BigInt {
        let acc: BigInt = new BigInt(this.at(this.length - 1))
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, new BigInt(this.at(i)), i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new BigInt64Array using fn(arr[i]) over all elements of current BigInt64Array.
    *
    * @param fn a function to apply for each element of current BigInt64Array
    *
    * @returns a new BigInt64Array where for each element from current BigInt64Array fn was applied
    */
    public map(fn: (val: BigInt, index: number) => BigInt): BigInt64Array {
        let resBuf = new ArrayBuffer(this.length * BigInt64Array.BYTES_PER_ELEMENT)
        let res = new BigInt64Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(new BigInt(this.at(i)), i as double as number).getLong())
        }
        return res
    }

    /**
     * Checks that all elements of BigInt64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt, index: number, array: BigInt64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(new BigInt(this.at(i)), i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of BigInt64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: BigInt, index: number) => boolean): boolean {
        let newF: (element: long, index: int, array: BigInt64Array) => boolean =
            (element: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(element), index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new BigInt64Array from current BigInt64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): BigInt64Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(new BigInt(this.at(i)), i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * BigInt64Array.BYTES_PER_ELEMENT)
        let res = new BigInt64Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new BigInt64Array from current BigInt64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new BigInt64Array with elements from current BigInt64Array that satisfy condition fn
     */
    public filter(fn: (val: BigInt, index: number) => boolean): BigInt64Array {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return long | undefined as in JS
     */
    public find(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): long {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return val
            }
        }
        throw new Error("BigInt64Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: BigInt, index: number) => boolean): long {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: BigInt, index: number) => boolean): number {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): long {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return val
            }
        }
        throw new Error("BigInt64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: BigInt, index: number) => boolean): long {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: number, array: BigInt64Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(new BigInt(val), i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the BigInt64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: BigInt, index: number) => boolean): number {
        let newF: (val: long, index: int, array: BigInt64Array) => boolean =
            (val: long, index: int, array: BigInt64Array): boolean => { return fn(new BigInt(val), index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of BigInt64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt, index: number, array: BigInt64Array) => long): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(new BigInt(this.at(i)), i as double as number, this))
        }
        throw new Error("BigInt64Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of BigInt64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: BigInt, index: number) => long): void {
        let newF: (val: long, index: int, array: BigInt64Array) => long =
            (val: long, index: int, array: BigInt64Array): long => { return fn(new BigInt(val), index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an BigInt64Array from array-like argument
     *
     * @param o array-like object to initialize BigInt64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new BigInt64Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => long): BigInt64Array {
        throw new Error("BigInt64Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: Buffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of long stored in BigInt64Array */
    public readonly length: int

    /** String \"BigInt64Array\" */
    public readonly name = "BigInt64Array"
}

/**
 * JS Float32Array API-compatible class
 */
export final class Float32Array {
    public static readonly BYTES_PER_ELEMENT = 4

    /**
     * Creates an empty Float32Array.
     */
    public constructor() {
        this(new ArrayBuffer(0), 0, 0)
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: Buffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Float32Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type float in newly created Float32Array
     */
    public constructor(buf: Buffer, byteOffset: int, length: int) {
        if (buf.getByteLength() % Float32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Float32Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 4 as Float32Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Float32Array.BYTES_PER_ELEMENT > buf.getByteLength()) {
            throw new RangeError("Range Error: attempt to create Float32Array where length * Float32Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.getByteLength() - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Float32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: int) {
        this(buf, byteOffset, buf.getByteLength() / Float32Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Float32Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Float32Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: Buffer) {
        this(buf, 0, buf.getByteLength() / Float32Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Float32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this.length = length
        this.byteLength = length * Float32Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Float32Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Float32Array.
     *
     * @param other data initializer
     */
    public constructor(other: Float32Array) {
        this.buffer = other.buffer.sliceInternal(0, other.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as double as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): float {
        if (index < 0) {
            index = this.length + index
        }
        let byteIndex = index * Float32Array.BYTES_PER_ELEMENT + this.byteOffset
        let res: int = 0
        for (let i = 0; i < Float32Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = this.buffer.at(byteIndex + i) as int
            byteVal &= 0xff
            res = (res | byteVal << (8 * i)) as int;
        }
        return Float.bitCastFromInt(res)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: int, startPos: int, endPos: int): void {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Float32Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Float32Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Float32Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Float32Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    /* public */ internal entries(): MapIterator<Int, Float> {
        let ret: Entry<Int, Float>[] = new Entry<Int, Float>[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = new Entry<Int, Float>(i, this.at(i));
        }
        return new MapIterator<Int, Float>(ret);
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start: number, end: number): Float32Array {
        return this.fill(value as double as int as float, start as int, end as int)
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start: int, end: int): Float32Array {
        if (start < -this.length) {
            start = 0
        }
        if (start < 0) {
            start += this.length
        }
        if (start >= this.length) {
            return this;
        }
        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end += this.length
        }
        if (end >= this.length) {
            end = this.length
        }
        for (let i = start; i < end; ++i) {
            this.set(i, value)
        }
        return this;
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: number, start: number): Float32Array {
        return this.fill(value as double as int as float, start as int)
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float, start: int): Float32Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Float32Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float32Array
     */
    public fill(value: float): Float32Array {
        return this.fill(value, 0, this.length)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(float[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as double as int as float)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(float[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: float): void {
        if (insertPos < 0 || insertPos >= this.length) {
            throw new RangeError("set: insertPos is out-of-bounds")
        }

        let startByte = insertPos * Float32Array.BYTES_PER_ELEMENT + this.byteOffset
        let bits = Float.bitCastToInt(val);
        for (let i = 0; i < Float32Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
            this.buffer.set(startByte + i, byteVal)
        }
    }

    /**
     * Copies all elements of arr to the current Float32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: float[]): size of arr is greater than Float32Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as double as int as float)
        }
    }

    /**
     * Copies all elements of arr to the current Float32Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: float[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: float[]): size of arr is greater than Float32Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }


    /**
     * Copies all elements of arr to the current Float32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: number[]): void {
        this.set(arr, 0)
    }

    /**
     * Copies all elements of arr to the current Float32Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: float[]): void {
        this.set(arr, 0)
    }

    /**
     * Creates an Float32Array from array-like argument
     *
     * @param o array-like object to initialize Float32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Float32Array
     */
    public from(o: Object, mapFn: (e: Object) => float): Float32Array {
        let newF: (e: Object, index: int) => float =
            (e: Object, index: int): float => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Float32Array from array-like argument
     *
     * @param o array-like object to initialize Float32Array
     *
     * @returns new Float32Array
     */
    public from(o: Object): Float32Array {
        throw new Error("Float32Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Float32Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Float32Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as double as int as float, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Float32Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Float32Array, false otherwise
     */
    public includes(e: float, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }


    /**
     * Checks if specified argument is in Float32Array
     *
     * @param e search element
     *
     * @returns true if e is in Float32Array, false otherwise
     */
    public includes(e: number): boolean {
        return this.includes(e as double as int as float, 0)
    }

    /**
     * Checks if specified argument is in Float32Array
     *
     * @param e search element
     *
     * @returns true if e is in Float32Array, false otherwise
     */
    public includes(e: float): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as double as int as float, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: float, fromIndex: int): int {
        if (fromIndex >= this.length) {
            return -1
        }
        if (fromIndex < 0) {
            fromIndex += this.length
            // See TypedArray.indexOf JS docs
            if (fromIndex < 0) {
                fromIndex = 0
            }
        }
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return i
            }
        }
        return -1
    }


    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number): number {
        return this.indexOf(e as double as int as float)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: float): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Float32Array
     *
     * @returns iterator over keys
     */
    public keys(): ValuesIterator<Int> {
        let ret: Int[] = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = i;
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as double as int as float, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: float, fromIndex: int): int {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }


    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: number): number {
        return this.lastIndexOf(val as double as int as float, this.length - 1)
    }

    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: float): int {
        return this.lastIndexOf(val, this.length - 1)
    }

   /**
    * Creates a new Float32Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Float32Array from data
    */
    public of(data: Object[]): Float32Array {
        throw new Error("Float32Array.of: not implemented")
    }

    /**
     * Creates a new Float32Array using reversed data from the current one
     *
     * @returns a new Float32Array using reversed data from the current one
     */
    public reverse(): Float32Array {
        let res = new Float32Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
     public slice(begin: number, end: number): Float32Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Float32Array {
        let buf = this.buffer.sliceInternal(begin * Float32Array.BYTES_PER_ELEMENT, end * Float32Array.BYTES_PER_ELEMENT)
        return new Float32Array(buf)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin, this.length)
     */
    public slice(begin: number): Float32Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Float32Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float32Array with elements of current Float32Array[begin, this.length)
     */
    public slice(begin: int): Float32Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Float32 with all elements.
     *
     * @returns a new Float32Array with elements of current Float32Array
     */
    public slice(): Float32Array {
        return new Float32Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Float32Array
     */
    public sort(): Float32Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => {
            const a1 = a as double as int as float
            const b1 = b as double as int as float
            return a1 < b1 ? -1 : a1 == b1 ? 0 : 1
        }
        return this.sort(newF)
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Float32Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float32Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float32Array with the same underlying ArrayBuffer
     */
    public subarray(begin: int, end: int): Float32Array {
        return new Float32Array(this.buffer, begin * Float32Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Float32Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Float32Array with the same ArrayBuffer
     */
    public subarray(begin: number): Float32Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Float32Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Float32Array with the same ArrayBuffer
     */
    public subarray(begin: int): Float32Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Float32Array with the same ArrayBuffer
     *
     * @returns new Float32Array with the same ArrayBuffer
     */
    public subarray(): Float32Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Float32Array.toLocaleString: not implemented")
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Float32Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Float32Array {
        return new Float32Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Float32Array {
        return new Float32Array(this).sort()
    }

    /**
     * Returns a string representation of the Float32Array
     *
     * @returns a string representation of the Float32Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): ValuesIterator<Float> {
        const ret = new Float[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = this.at(i);
        }
        return new ValuesIterator<Float>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float32Array with replaced value on index
     */
    public with(index: number, value: number): Float32Array {
        return this.with(index as int, value as double as int as float)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float32Array with replaced value on index
     */
    public with(index: int, value: float): Float32Array {
        let res = new Float32Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===
    /**
     * Checks that all elements of Float32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: float) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element) }
        return this.every(newF)
    }
    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: float) => boolean): Float32Array {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: float) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: float) => boolean): int {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: float) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: float) => boolean): int {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Float32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: float) => float): void {
        let newF: (val: float, index: int, array: Float32Array) => float =
            (val: float, index: int, array: Float32Array): float => { return fn(val) }
        this.forEach(newF)
    }

   /**
    * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array
    *
    * @param fn a function to apply for each element of current Float32Array
    *
    * @returns a new Float32Array where for each element from current Float32Array fn was applied
    */
    public map(fn: (val: float) => float): Float32Array {
        let newF: (val: float, index: int) => float =
            (val: float, index: int): float => { return fn(val) }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Float32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: float) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Float32Array
     */
    public sort(fn: (a: float, b: float) => int): Float32Array {
        let arr: float[] = new float[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: float, b: float) => boolean =
                (a: float, b: float): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Float32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: float, index: int, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Float32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: float, index: int) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: float, curVal: float, curIndex: int, array: Float32Array) => float, init: float): float {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: float, curVal: float, curIndex: int, array: Float32Array) => float): float {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: float, curVal: float, curIndex: int, array: Float32Array) => float, init: float): float {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: float, curVal: float, curIndex: int, array: Float32Array) => float): float {
        let acc: float = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array.
    *
    * @param fn a function to apply for each element of current Float32Array
    *
    * @returns a new Float32Array where for each element from current Float32Array fn was applied
    */
    public map(fn: (val: float, index: int) => float): Float32Array {
        let resBuf = new ArrayBuffer(this.length * Float32Array.BYTES_PER_ELEMENT)
        let res = new Float32Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Float32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: float, index: int, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Float32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: float, index: int) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Float32Array from current Float32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: float, index: int, array: Float32Array) => boolean): Float32Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float32Array.BYTES_PER_ELEMENT)
        let res = new Float32Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: float, index: int) => boolean): Float32Array {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float32Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return float | undefined as in JS
     */
    public find(fn: (val: float, index: int, array: Float32Array) => boolean): float {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Float32Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: float, index: int) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: float, index: int, array: Float32Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: float, index: int) => boolean): int {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: float, index: int, array: Float32Array) => boolean): float {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Float32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: float, index: int) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: float, index: int, array: Float32Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: float, index: int) => boolean): int {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Float32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: float, index: int, array: Float32Array) => float): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Float32Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Float32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: float, index: int) => float): void {
        let newF: (val: float, index: int, array: Float32Array) => float =
            (val: float, index: int, array: Float32Array): float => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Float32Array from array-like argument
     *
     * @param o array-like object to initialize Float32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Float32Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => float): Float32Array {
        throw new Error("Float32Array.from: not implemented")
    }
    /**
     * Checks that all elements of Float32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element as double as number) }
        return this.every(newF)
    }
    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Float32Array {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number) }
        return this.findLast(newF) as double as number
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Float32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => float): void {
        let newF: (val: float, index: int, array: Float32Array) => float =
            (val: float, index: int, array: Float32Array): float => { return fn(val as double as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array
    *
    * @param fn a function to apply for each element of current Float32Array
    *
    * @returns a new Float32Array where for each element from current Float32Array fn was applied
    */
    public map(fn: (val: number) => number): Float32Array {
        let newF: (val: float, index: int) => float =
            (val: float, index: int): float => { return fn(val as double as number) as double as int as float }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Float32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element as double as number) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Float32Array
     */
    public sort(fn: (a: number, b: number) => number): Float32Array {
        let arr: float[] = new float[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: float, b: float) => boolean =
                (a: float, b: float): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Float32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as double as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Float32Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Float32Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Float32Array) => number): number {
        let acc = this.at(0) as double as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Float32Array) => number, init: number): number {
        let acc = init as double as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Float32Array) => number): number {
        let acc: number = this.at(this.length - 1) as double as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Float32Array using fn(arr[i]) over all elements of current Float32Array.
    *
    * @param fn a function to apply for each element of current Float32Array
    *
    * @returns a new Float32Array where for each element from current Float32Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Float32Array {
        let resBuf = new ArrayBuffer(this.length * Float32Array.BYTES_PER_ELEMENT)
        let res = new Float32Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as double as number, i as double as number) as double as int as float)
        }
        return res
    }

    /**
     * Checks that all elements of Float32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Float32Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as double as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Float32Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: float, index: int, array: Float32Array) => boolean =
            (element: float, index: int, array: Float32Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Float32Array from current Float32Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Float32Array) => boolean): Float32Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as double as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float32Array.BYTES_PER_ELEMENT)
        let res = new Float32Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Float32Array from current Float32Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float32Array with elements from current Float32Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Float32Array {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float32Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return float | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Float32Array) => boolean): float {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Float32Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Float32Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Float32Array) => boolean): float {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Float32Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): float {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Float32Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Float32Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: float, index: int, array: Float32Array) => boolean =
            (val: float, index: int, array: Float32Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Float32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Float32Array) => float): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as double as number, i as double as number, this))
        }
        throw new Error("Float32Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Float32Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => float): void {
        let newF: (val: float, index: int, array: Float32Array) => float =
            (val: float, index: int, array: Float32Array): float => { return fn(val as double as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Float32Array from array-like argument
     *
     * @param o array-like object to initialize Float32Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Float32Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => float): Float32Array {
        throw new Error("Float32Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: Buffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of float stored in Float32Array */
    public readonly length: int

    /** String \"Float32Array\" */
    public readonly name = "Float32Array"
}

/**
 * JS Float64Array API-compatible class
 */
export final class Float64Array {
    public static readonly BYTES_PER_ELEMENT = 8

    /**
     * Creates an empty Float64Array.
     */
    public constructor() {
        this(new ArrayBuffer(0), 0, 0)
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: Buffer, byteOffset: number, length: number) {
        this(buf, byteOffset as int, length as int)
    }

    /**
     * Creates an Float64Array with respect to data, byteOffset and length.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     *
     * @param length size of elements of type double in newly created Float64Array
     */
    public constructor(buf: Buffer, byteOffset: int, length: int) {
        if (buf.getByteLength() % Float64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("ArrayBuffer.byteLength should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
        }
        if (byteOffset % Float64Array.BYTES_PER_ELEMENT != 0) {
            throw new RangeError("byteOffset should be multiple of 8 as Float64Array.BYTES_PER_ELEMENT")
        }

        if (this.length * Float64Array.BYTES_PER_ELEMENT > buf.getByteLength()) {
            throw new RangeError("Range Error: attempt to create Float64Array where length * Float64Array.BYTES_PER_ELEMENT > ArrayBuffer.byteLength")
        }
        this.byteLength = buf.getByteLength() - byteOffset
        this.byteOffset = byteOffset
        this.length = length
        this.buffer = buf
    }

    /**
     * Creates an Float64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: int) {
        this(buf, byteOffset, buf.getByteLength() / Float64Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Float64Array with respect to buf and byteOffset.
     *
     * @param buf data initializer
     *
     * @param byteOffset byte offset from begin of the buf
     */
    public constructor(buf: Buffer, byteOffset: number) {
        this(buf, byteOffset as int)
    }

    /**
     * Creates an Float64Array with respect to buf.
     *
     * @param buf data initializer
     */
    public constructor(buf: Buffer) {
        this(buf, 0, buf.getByteLength() / Float64Array.BYTES_PER_ELEMENT)
    }

    /**
     * Creates an Float64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: int) {
        this.length = length
        this.byteLength = length * Float64Array.BYTES_PER_ELEMENT
        this.byteOffset = 0
        this.buffer = new ArrayBuffer(this.byteLength)
    }

    /**
     * Creates an Float64Array with respect to length.
     *
     * @param length data initializer
     */
    public constructor(length: number) {
        this(length as int)
    }

    /**
     * Creates a copy of Float64Array.
     *
     * @param other data initializer
     */
    public constructor(other: Float64Array) {
        this.buffer = other.buffer.sliceInternal(0, other.byteLength)
        this.byteLength = other.byteLength
        this.length = other.length
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: number): number {
        return this.at(index as int) as double as number
    }

    /**
     * Returns an instance of primitive type at passed index.
     *
     * @param index index to look at
     *
     * @returns a primitive at index
     */
    public at(index: int): double {
        if (index < 0) {
            index = this.length + index
        }
        let byteIndex = index * Float64Array.BYTES_PER_ELEMENT + this.byteOffset
        let res: long = 0
        for (let i = 0; i < Float64Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = this.buffer.at(byteIndex + i) as long
            byteVal &= 0xff
            res = (res | byteVal << (8 * i)) as long;
        }
        return Double.bitCastFromLong(res)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: number, startPos: number, endPos: number): void {
        this.copyWithin(insertPos as int, startPos as int, endPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to endPos.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * @param endPos last index to end copy from, excluded
     *
     * See rules of parameters normalization on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin | MDN}
     */
    public copyWithin(insertPos: int, startPos: int, endPos: int): void {
        if (insertPos < -this.length) {
            insertPos = 0
        }
        if (insertPos >= this.length) {
            return
        }
        if (insertPos < 0) {
            insertPos = this.length + insertPos
        }

        if (startPos < -this.length) {
            startPos = 0
        }
        if (startPos >= this.length) {
            return
        }
        if (startPos < 0) {
            startPos = this.length + startPos
        }

        if (endPos < -this.length) {
            endPos = 0
        }
        if (endPos < 0) {
            endPos = this.length + endPos
        }
        if (endPos > this.length) {
            endPos = this.length
        }
        if (endPos < startPos) {
            return
        }

        for (let i = startPos; i < endPos; ++i) {
            this.set(insertPos + i - startPos, this.at(i))
        }
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Float64Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number, startPos: number): void {
        this.copyWithin(insertPos as int, startPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from startPos to end of Float64Array.
     *
     * @param insertPos insert index to place copied elements
     *
     * @param startPos start index to begin copy from
     *
     * See rules of parameters normalization {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int, startPos: int): void {
        this.copyWithin(insertPos, startPos, this.length)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Float64Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: number): void {
        this.copyWithin(insertPos as int)
    }

    /**
     * Makes a copy of internal elements to insertPos from begin to end of Float64Array.
     *
     * See rules of parameters normalization:
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin}
     */
    public copyWithin(insertPos: int): void {
        this.copyWithin(insertPos, 0, this.length)
    }

    /**
     * Returns an iterator for all entries
     */
    /* public */ internal entries(): MapIterator<Int, Double> {
        let ret: Entry<Int, Double>[] = new Entry<Int, Double>[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = new Entry<Int, Double>(i, this.at(i));
        }
        return new MapIterator<Int, Double>(ret);
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start: number, end: number): Float64Array {
        return this.fill(value as double as int as double, start as int, end as int)
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: double, start: int, end: int): Float64Array {
        if (start < -this.length) {
            start = 0
        }
        if (start < 0) {
            start += this.length
        }
        if (start >= this.length) {
            return this;
        }
        if (end < -this.length) {
            end = 0
        }
        if (end < 0) {
            end += this.length
        }
        if (end >= this.length) {
            end = this.length
        }
        for (let i = start; i < end; ++i) {
            this.set(i, value)
        }
        return this;
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: number, start: number): Float64Array {
        return this.fill(value as double as int as double, start as int)
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: double, start: int): Float64Array {
        return this.fill(value, start, this.length)
    }

    /**
     * Fills the Float64Array with specified value
     *
     * @param value new valuy
     *
     * @returns modified Float64Array
     */
    public fill(value: double): Float64Array {
        return this.fill(value, 0, this.length)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(double[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: number, val: number): void {
        this.set(insertPos as int, val as double as int as double)
    }

    /**
     * Assigns val as element on insertPos.
     * @description Added to avoid (un)packing a single value into array to use overloaded set(double[], insertPos)
     *
     * @param val value to set
     *
     * @param insertPos index to change
     */
    public set(insertPos: int, val: double): void {
        if (insertPos < 0 || insertPos >= this.length) {
            throw new RangeError("set: insertPos is out-of-bounds")
        }

        let startByte = insertPos * Float64Array.BYTES_PER_ELEMENT + this.byteOffset
        let bits = Double.bitCastToLong(val);
        for (let i = 0; i < Float64Array.BYTES_PER_ELEMENT; ++i) {
            let byteVal = ((bits >>> (i * 8)) & 0xff) as byte
            this.buffer.set(startByte + i, byteVal)
        }
    }

    /**
     * Copies all elements of arr to the current Float64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: number[], insertPos1: number): void {
        const insertPos = insertPos1 as int
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: double[]): size of arr is greater than Float64Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i] as double as int as double)
        }
    }

    /**
     * Copies all elements of arr to the current Float64Array starting from insertPos.
     *
     * @param arr array to copy data from
     *
     * @param insertPos start index where data from arr will be inserted
     *
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}
     */
    public set(arr: double[], insertPos: int): void {
        if (insertPos < 0 || insertPos + arr.length > this.length) {
            throw new RangeError("set(insertPos: int, arr: double[]): size of arr is greater than Float64Array.length")
        }
        for (let i = 0; i < arr.length; ++i) {
            this.set(insertPos + i, arr[i])
        }
    }



    /**
     * Copies all elements of arr to the current Float64Array.
     *
     * @param arr array to copy data from
     */
    public set(arr: double[]): void {
        this.set(arr, 0)
    }

    /**
     * Creates an Float64Array from array-like argument
     *
     * @param o array-like object to initialize Float64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Float64Array
     */
    public from(o: Object, mapFn: (e: Object) => double): Float64Array {
        let newF: (e: Object, index: int) => double =
            (e: Object, index: int): double => { return mapFn(e) }
        return this.from(o, newF)
    }

    /**
     * Creates an Float64Array from array-like argument
     *
     * @param o array-like object to initialize Float64Array
     *
     * @returns new Float64Array
     */
    public from(o: Object): Float64Array {
        throw new Error("Float64Array.from: not implemented")
    }

    /**
     * Checks if specified argument is in Float64Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Float64Array, false otherwise
     */
    public includes(e: number, fromIndex: number): boolean {
        return this.includes(e as double as int as double, fromIndex as int)
    }

    /**
     * Checks if specified argument is in Float64Array
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns true if e is in Float64Array, false otherwise
     */
    public includes(e: double, fromIndex: int): boolean {
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return true
            }
        }
        return false
    }



    /**
     * Checks if specified argument is in Float64Array
     *
     * @param e search element
     *
     * @returns true if e is in Float64Array, false otherwise
     */
    public includes(e: double): boolean {
        return this.includes(e, 0)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: number, fromIndex: number): number {
        return this.indexOf(e as double as int as double, fromIndex as int)
    }

    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @param fromIndex start index to search from
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: double, fromIndex: int): int {
        if (fromIndex >= this.length) {
            return -1
        }
        if (fromIndex < 0) {
            fromIndex += this.length
            // See TypedArray.indexOf JS docs
            if (fromIndex < 0) {
                fromIndex = 0
            }
        }
        for (let i = fromIndex; i < this.length; ++i) {
            if (this.at(i) == e) {
                return i
            }
        }
        return -1
    }



    /**
     * Returns index of specified element
     *
     * @param e search element
     *
     * @returns index of element if it presents, -1 otherwise
     */
    public indexOf(e: double): int {
        return this.indexOf(e, 0)
    }

    /**
     * Joins data to a string
     *
     * @param s separator
     *
     * @returns joined representation
     */
    public join(s: string): string {
        let res: StringBuilder = new StringBuilder("")
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(s)
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Joins data to a string
     *
     * @returns joined representation with comma separator
     */
    public join(): string {
        return this.join(",")
    }

    /**
     * Returns keys of the Float64Array
     *
     * @returns iterator over keys
     */
    public keys(): ValuesIterator<Int> {
        let ret: Int[] = new Int[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = i;
        }
        return new ValuesIterator<Int>(ret);
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: number, fromIndex: number): number {
        return this.lastIndexOf(val as double as int as double, fromIndex as int)
    }

    /**
     * Moves backwards starting at fromIndex to 0 and search val.
     *
     * @param val a value to search
     *
     * @param fromIndex the first index to search val at, i.e. fromIndex is included in search space
     *
     * @returns right-most index of val. It must be less or equal than fromIndex. -1 if val not found
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf
     */
    public lastIndexOf(val: double, fromIndex: int): int {
        if (fromIndex >= this.length) {
            fromIndex = this.length - 1
        }
        if (fromIndex < 0) {
            fromIndex = this.length + fromIndex
        }

        for (let i = fromIndex; i >= 0; --i) {
            if (this.at(i) == val) {
                return i
            }
        }
        return -1
    }



    /**
     * Moves backwards and search val.
     *
     * @param val a value to search
     *
     * @returns right-most index of val. -1 if val not found
     */
    public lastIndexOf(val: double): int {
        return this.lastIndexOf(val, this.length - 1)
    }

   /**
    * Creates a new Float64Array using initializer
    *
    * @param data initializer
    *
    * @returns a new Float64Array from data
    */
    public of(data: Object[]): Float64Array {
        throw new Error("Float64Array.of: not implemented")
    }

    /**
     * Creates a new Float64Array using reversed data from the current one
     *
     * @returns a new Float64Array using reversed data from the current one
     */
    public reverse(): Float64Array {
        let res = new Float64Array(this)
        for (let i = 0; i < this.length; ++i) {
            res.set(this.length - 1 - i, this.at(i))
        }
        return res
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
     public slice(begin: number, end: number): Float64Array {
        return this.slice(begin as int, end as int)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, end)
     *
     * @param begin start index to be taken into slice
     *
     * @param end last index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin;end) where end index is excluded
     *
     * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice
     */
    public slice(begin: int, end: int): Float64Array {
        let buf = this.buffer.sliceInternal(begin * Float64Array.BYTES_PER_ELEMENT, end * Float64Array.BYTES_PER_ELEMENT)
        return new Float64Array(buf)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin, this.length)
     */
    public slice(begin: number): Float64Array {
        return this.slice(begin as int)
    }

    /**
     * Creates a slice of current Float64Array using range [begin, this.length).
     *
     * @param begin start index to be taken into slice
     *
     * @returns a new Float64Array with elements of current Float64Array[begin, this.length)
     */
    public slice(begin: int): Float64Array {
        return this.slice(begin, this.length)
    }

    /**
     * Creates a slice of current Float64 with all elements.
     *
     * @returns a new Float64Array with elements of current Float64Array
     */
    public slice(): Float64Array {
        return new Float64Array(this)
    }

    /**
     * Sorts in-place according to the numeric ordering
     *
     * @returns sorted Float64Array
     */
    public sort(): Float64Array {
        let newF: (a: number, b: number) => number = (a: number, b: number): number => {
            const a1 = a as double as int as double
            const b1 = b as double as int as double
            return a1 < b1 ? -1 : a1 == b1 ? 0 : 1
        }
        return this.sort(newF)
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBuffer
     */
    public subarray(begin: number, end: number): Float64Array {
        return this.subarray(begin as int, end as int)
    }

    /**
     * Creates a Float64Array with the same underlying ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @param end last index, exclusive
     *
     * @returns new Float64Array with the same underlying ArrayBuffer
     */
    public subarray(begin: int, end: int): Float64Array {
        return new Float64Array(this.buffer, begin * Float64Array.BYTES_PER_ELEMENT, end - begin)
    }

    /**
     * Creates a Float64Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Float64Array with the same ArrayBuffer
     */
    public subarray(begin: number): Float64Array {
        return this.subarray(begin as int)
    }

    /**
     * Creates a Float64Array with the same ArrayBuffer
     *
     * @param begin start index, inclusive
     *
     * @returns new Float64Array with the same ArrayBuffer
     */
    public subarray(begin: int): Float64Array {
        return this.subarray(begin, this.length)
    }

    /**
     * Creates a Float64Array with the same ArrayBuffer
     *
     * @returns new Float64Array with the same ArrayBuffer
     */
    public subarray(): Float64Array {
        return this.subarray(0, this.length)
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @param locales
     *
     * @param options
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object, options: Object): string {
        throw new Error("Float64Array.toLocaleString: not implemented")
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @param locales
     *
     * @returns string representation
     */
    public toLocaleString(locales: Object): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Converts Float64Array to a string with respect to locale
     *
     * @returns string representation
     */
    public toLocaleString(): string {
        return this.toLocaleString(new Object(), new Object())
    }

    /**
     * Creates a reversed copy
     *
     * @returns a reversed copy
     */
    public toReversed(): Float64Array {
        return new Float64Array(this).reverse()
    }

    /**
     * Creates a sorted copy
     *
     * @returns a sorted copy
     */
    public toSorted(): Float64Array {
        return new Float64Array(this).sort()
    }

    /**
     * Returns a string representation of the Float64Array
     *
     * @returns a string representation of the Float64Array
     */
    public override toString(): string {
        let res = new StringBuilder();
        for (let i = 0; i < this.length - 1; ++i) {
            res.append(this.at(i))
            res.append(c',')
        }
        if (this.length > 0) {
            res.append(this.at(this.length - 1))
        }
        return res.toString()
    }

    /**
     * Returns array values iterator
     *
     * @returns an iterator
     */
    public values(): ValuesIterator<Double> {
        const ret = new Double[this.length];
        for (let i: int = 0; i < this.length; i++) {
            ret[i] = this.at(i);
        }
        return new ValuesIterator<Double>(ret);
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float64Array with replaced value on index
     */
    public with(index: number, value: number): Float64Array {
        return this.with(index as int, value as double as int as double)
    }

    /**
     * Creates a copy with replaced value on index
     *
     * @param index
     *
     * @param value
     *
     * @returns an Float64Array with replaced value on index
     */
    public with(index: int, value: double): Float64Array {
        let res = new Float64Array(this)
        res.set(index, value)
        return res
    }

    /// === with element lambda functions ===

    /**
     * Checks that at least one element of Float64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: double, index: int, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i), i, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Float64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: double, index: int) => boolean): boolean {
        let newF: (element: double, index: int, array: Float64Array) => boolean =
            (element: double, index: int, array: Float64Array): boolean => { return fn(element, index) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: double, curVal: double, curIndex: int, array: Float64Array) => double, init: double): double {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: double, curVal: double, curIndex: int, array: Float64Array) => double): double {
        let acc = this.at(0)
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: double, curVal: double, curIndex: int, array: Float64Array) => double, init: double): double {
        let acc = init
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: double, curVal: double, curIndex: int, array: Float64Array) => double): double {
        let acc: double = this.at(this.length - 1)
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i), i, this)
        }
        return acc
    }

    /**
    * Creates a new Float64Array using fn(arr[i]) over all elements of current Float64Array.
    *
    * @param fn a function to apply for each element of current Float64Array
    *
    * @returns a new Float64Array where for each element from current Float64Array fn was applied
    */
    public map(fn: (val: double, index: int) => double): Float64Array {
        let resBuf = new ArrayBuffer(this.length * Float64Array.BYTES_PER_ELEMENT)
        let res = new Float64Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i), i))
        }
        return res
    }

    /**
     * Checks that all elements of Float64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: double, index: int, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i), i, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Float64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: double, index: int) => boolean): boolean {
        let newF: (element: double, index: int, array: Float64Array) => boolean =
            (element: double, index: int, array: Float64Array): boolean => { return fn(element, index) }
        return this.every(newF)
    }

    /**
     * Creates a new Float64Array from current Float64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: double, index: int, array: Float64Array) => boolean): Float64Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i), i, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float64Array.BYTES_PER_ELEMENT)
        let res = new Float64Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Float64Array from current Float64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: double, index: int) => boolean): Float64Array {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val, index) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float64Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return double | undefined as in JS
     */
    public find(fn: (val: double, index: int, array: Float64Array) => boolean): double {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Float64Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: double, index: int) => boolean): double {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val, index) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: double, index: int, array: Float64Array) => boolean): int {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: double, index: int) => boolean): int {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val, index) }
        return this.findIndex(newF)
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: double, index: int, array: Float64Array) => boolean): double {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return val
            }
        }
        throw new Error("Float64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: double, index: int) => boolean): double {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val, index) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: double, index: int, array: Float64Array) => boolean): int {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val, i, this)) {
                return i
            }
        }
        return -1
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: double, index: int) => boolean): int {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val, index) }
        return this.findLastIndex(newF)
    }

    /**
     * Applies a function over all elements of Float64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: double, index: int, array: Float64Array) => double): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i), i, this))
        }
        throw new Error("Float64Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Float64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: double, index: int) => double): void {
        let newF: (val: double, index: int, array: Float64Array) => double =
            (val: double, index: int, array: Float64Array): double => { return fn(val, index) }
        this.forEach(newF)
    }

    /**
     * Creates an Float64Array from array-like argument
     *
     * @param o array-like object to initialize Float64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Float64Array
     */
    public from(o: Object, mapFn: (e: Object, index: int) => double): Float64Array {
        throw new Error("Float64Array.from: not implemented")
    }
    /**
     * Checks that all elements of Float64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number) => boolean): boolean {
        let newF: (element: double, index: int, array: Float64Array) => boolean =
            (element: double, index: int, array: Float64Array): boolean => { return fn(element as double as number) }
        return this.every(newF)
    }
    /**
     * creates a new Float64Array from current Float64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: number) => boolean): Float64Array {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number) => boolean): double {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number) => boolean): number {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number) => boolean): number {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number) }
        return this.findLast(newF) as double as number
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number) => boolean): number {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Float64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number) => double): void {
        let newF: (val: double, index: int, array: Float64Array) => double =
            (val: double, index: int, array: Float64Array): double => { return fn(val as double as number) }
        this.forEach(newF)
    }

   /**
    * Creates a new Float64Array using fn(arr[i]) over all elements of current Float64Array
    *
    * @param fn a function to apply for each element of current Float64Array
    *
    * @returns a new Float64Array where for each element from current Float64Array fn was applied
    */
    public map(fn: (val: number) => number): Float64Array {
        let newF: (val: double, index: int) => double =
            (val: double, index: int): double => { return fn(val as double as number) as double as int as double }
        return this.map(newF)
    }

    /**
     * Checks that at least one element of Float64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number) => boolean): boolean {
        let newF: (element: double, index: int, array: Float64Array) => boolean =
            (element: double, index: int, array: Float64Array): boolean => { return fn(element as double as number) }
        return this.some(newF)
    }

    // TODO(kprokopenko): this may be not skipped
    /**
     * Sorts in-place
     *
     * @param fn comparator
     *
     * @returns sorted Float64Array
     */
    public sort(fn: (a: number, b: number) => number): Float64Array {
        let arr: double[] = new double[this.length]
        for (let i = 0; i < this.length; ++i) {
            arr[i] = this.at(i)
        }
        // TODO(ivan-tyulyandin): unresolved reference i in for loop, blocked by internal issue 12961
        /*
            let mustPrecede: (a: double, b: double) => boolean =
                (a: double, b: double): boolean => { return (fn(a, b) <= 0) }
            sort(arr, mustPrecede)
            for (let i = 0; i < this.length; ++i) {
                this.set(i, arr[i])
            }
        */
        return this;
    }

    /**
     * Checks that at least one element of Float64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (fn(this.at(i) as double as number, i as double as number, this)) {
                return true
            }
        }
        return false
    }

    /**
     * Checks that at least one element of Float64Array satisfies the passed function
     *
     * @param fn check function
     *
     * @returns true if some element satisfies fn
     */
    public some(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: double, index: int, array: Float64Array) => boolean =
            (element: double, index: int, array: Float64Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.some(newF)
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Float64Array) => number, init: number): number {
        let acc = init
        for (let i = 0; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using left-to-right traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduce(fn: (acc: number, curVal: number, curIndex: number, array: Float64Array) => number): number {
        let acc = this.at(0) as double as number
        for (let i = 1; i < this.length; ++i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @param init initial value
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Float64Array) => number, init: number): number {
        let acc = init as double as number
        for (let i = this.length - 1; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
     * Reduces data into a single value using right-to-left traversal
     *
     * @param fn condition
     *
     * @returns reduction result
     */
    public reduceRight(fn: (acc: number, curVal: number, curIndex: number, array: Float64Array) => number): number {
        let acc: number = this.at(this.length - 1) as double as number
        for (let i = this.length - 2; i >= 0; --i) {
            acc = fn(acc, this.at(i) as double as number, i as double as number, this)
        }
        return acc
    }

    /**
    * Creates a new Float64Array using fn(arr[i]) over all elements of current Float64Array.
    *
    * @param fn a function to apply for each element of current Float64Array
    *
    * @returns a new Float64Array where for each element from current Float64Array fn was applied
    */
    public map(fn: (val: number, index: number) => number): Float64Array {
        let resBuf = new ArrayBuffer(this.length * Float64Array.BYTES_PER_ELEMENT)
        let res = new Float64Array(resBuf)
        for (let i = 0; i < this.length; ++i) {
            res.set(i, fn(this.at(i) as double as number, i as double as number) as double as int as double)
        }
        return res
    }

    /**
     * Checks that all elements of Float64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number, array: Float64Array) => boolean): boolean {
        for (let i = 0; i < this.length; ++i) {
            if (!fn(this.at(i) as double as number, i as double as number, this)) {
                return false
            }
        }
        return true
    }

    /**
     * Checks that all elements of Float64Array satisfy the passed function
     *
     * @param fn check function
     *
     * @returns true if all elements satisfy fn
     */
    public every(fn: (element: number, index: number) => boolean): boolean {
        let newF: (element: double, index: int, array: Float64Array) => boolean =
            (element: double, index: int, array: Float64Array): boolean => { return fn(element as double as number, index as double as number) }
        return this.every(newF)
    }

    /**
     * Creates a new Float64Array from current Float64Array based on a condition fn.
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number, array: Float64Array) => boolean): Float64Array {
        let markers = new boolean[this.length]
        let resLen = 0
        for (let i = 0; i < this.length; ++i) {
            markers[i] = fn(this.at(i) as double as number, i as double as number, this)
            if (markers[i]) {
                ++resLen
            }
        }
        let resBuf = new ArrayBuffer(resLen * Float64Array.BYTES_PER_ELEMENT)
        let res = new Float64Array(resBuf)
        for (let i = 0, j = 0; i < this.length; ++i) {
            if (markers[i]) {
                res.set(j, this.at(i))
                ++j
            }
        }
        return res
    }

    /**
     * creates a new Float64Array from current Float64Array based on a condition fn
     *
     * @param fn the condition to apply for each element
     *
     * @returns a new Float64Array with elements from current Float64Array that satisfy condition fn
     */
    public filter(fn: (val: number, index: number) => boolean): Float64Array {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.filter(newF)
    }

    /**
     * Finds the first element in the Float64Array that satisfies the condition
     *
     * @param fn the condition to apply for each element
     *
     * @returns the first element that satisfies fn
     * TODO: return double | undefined as in JS
     */
    public find(fn: (val: number, index: number, array: Float64Array) => boolean): double {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Float64Array.find: not implemented if element was not found")
    }

    /**
     * Finds the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the first element that satisfies fn
     */
    public find(fn: (val: number, index: number) => boolean): double {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.find(newF)
    }

    /**
     * Finds an index of the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number, array: Float64Array) => boolean): number {
        for (let i = 0; i < this.length; ++i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i as double as number
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the first element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the first element that satisfies fn
     */
    public findIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findIndex(newF) as double as number
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number, array: Float64Array) => boolean): double {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return val
            }
        }
        throw new Error("Float64Array.findLast: not implemented if an element was not found")
    }

    /**
     * Finds the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the last element that satisfies fn
     */
    public findLast(fn: (val: number, index: number) => boolean): double {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLast(newF)
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number, array: Float64Array) => boolean): number {
        for (let i = this.length - 1; i >= 0; --i) {
            let val = this.at(i)
            if (fn(val as double as number, i as double as number, this)) {
                return i
            }
        }
        return -1 as double as number
    }

    /**
     * Finds an index of the last element in the Float64Array that satisfies the condition
     *
     * @param fn condition
     *
     * @returns the index of the last element that satisfies fn, -1 otherwise
     */
    public findLastIndex(fn: (val: number, index: number) => boolean): number {
        let newF: (val: double, index: int, array: Float64Array) => boolean =
            (val: double, index: int, array: Float64Array): boolean => { return fn(val as double as number, index as double as number) }
        return this.findLastIndex(newF) as double as number
    }

    /**
     * Applies a function over all elements of Float64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number, array: Float64Array) => double): void {
        for (let i = 0; i < this.length; ++i) {
            this.set(i, fn(this.at(i) as double as number, i as double as number, this))
        }
        throw new Error("Float64Array.forEach: has to return undefined, but returns void for now")
    }

    /**
     * Applies a function over all elements of Float64Array
     *
     * @param fn function to apply
     *
     * @returns undefined
     */
    public forEach(fn: (val: number, index: number) => double): void {
        let newF: (val: double, index: int, array: Float64Array) => double =
            (val: double, index: int, array: Float64Array): double => { return fn(val as double as number, index as double as number) }
        this.forEach(newF)
    }

    /**
     * Creates an Float64Array from array-like argument
     *
     * @param o array-like object to initialize Float64Array
     *
     * @param mapFn function to apply for each
     *
     * @returns new Float64Array
     */
    public from(o: Object, mapFn: (e: Object, index: number) => double): Float64Array {
        throw new Error("Float64Array.from: not implemented")
    }

    /** Underlying ArrayBuffer */
    public readonly buffer: Buffer

    /** Byte offset within the underlying ArrayBuffer */
    public readonly byteOffset: int

    /** Number of bytes used */
    public readonly byteLength: int

    /** Number of double stored in Float64Array */
    public readonly length: int

    /** String \"Float64Array\" */
    public readonly name = "Float64Array"
}
