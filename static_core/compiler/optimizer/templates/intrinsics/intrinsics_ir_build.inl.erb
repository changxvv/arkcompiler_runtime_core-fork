/**
 * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

inline bool NeedSafePointAfterIntrinsic(RuntimeInterface::IntrinsicId intrinsic) {
    switch (intrinsic) // NOLINT(hicpp-multiway-paths-covered)
    {
% Compiler::intrinsics.select {|intrinsic| intrinsic.safepoint_after_call}.each do |intrinsic|
    case panda::compiler::RuntimeInterface::IntrinsicId::<%= intrinsic.entrypoint_name %>:
        return true;
% end
    default:
        return false;
    }
}

#ifndef ONLY_NEEDSAFEPOINT
template <bool IS_VIRTUAL>
void InstBuilder::AddArgNullcheckIfNeeded([[maybe_unused]] RuntimeInterface::IntrinsicId intrinsic,
                                          [[maybe_unused]] Inst *inst, [[maybe_unused]] Inst *save_state,
                                          [[maybe_unused]] size_t bc_addr)
{
% if Compiler::intrinsics.any? {|intrinsic| !intrinsic.need_nullcheck.empty?}
    constexpr int ARG_OFFSET = IS_VIRTUAL ? 1 : 0;
    // NOLINTNEXTLINE(hicpp-multiway-paths-covered)
    switch (intrinsic)
    {
% Compiler::intrinsics.select {|intrinsic| !intrinsic.need_nullcheck.empty?}.each do |intrinsic|
    case panda::compiler::RuntimeInterface::IntrinsicId::<%= intrinsic.entrypoint_name %>:
% intrinsic.need_nullcheck.each do |arg_num|
        {
            auto null_check = graph_->CreateInstNullCheck(DataType::REFERENCE, bc_addr, inst->GetInput(ARG_OFFSET + <%= arg_num %>).GetInst(), save_state);
            inst->SetInput(ARG_OFFSET + <%= arg_num %>, null_check);
            AddInstruction(null_check);
        }
% end
        break;
% end
    default:
        break;
    }
% end
}

// NOLINTNEXTLINE(misc-definitions-in-headers, readability-function-size)
inline bool IsVirtual([[maybe_unused]] RuntimeInterface::IntrinsicId intrinsic)
{
% if Compiler::intrinsics.any? {|intrinsic| !intrinsic.static}
    switch (intrinsic)
    {
% Compiler::intrinsics.select {|intrinsic| intrinsic.has_impl? && !intrinsic.static}.each do |intrinsic|
    case panda::compiler::RuntimeInterface::IntrinsicId::<%= intrinsic.entrypoint_name %>:
        return true;
% end
    default:
        return false;
    }
% else
    return false;
% end
}

// NOLINTNEXTLINE(misc-definitions-in-headers)
void InstBuilder::BuildVirtualCallIntrinsic([[maybe_unused]] const BytecodeInstruction *bc_inst,
                                            [[maybe_unused]] bool is_range, [[maybe_unused]] bool acc_read)
{
% if Compiler::ext_intrinsic_spaces.any?
    auto method_index = bc_inst->GetId(0).AsIndex();
    auto method_id = GetRuntime()->ResolveMethodIndex(GetMethod(), method_index);
    auto method = GetRuntime()->GetMethodById(GetMethod(), method_id);
    auto intrinsic_id = GetRuntime()->GetIntrinsicId(method);
    // NOLINTNEXTLINE(hicpp-multiway-paths-covered)
    switch (intrinsic_id) {
#include "intrinsics_ir_build_virtual_call.inl"
        default: {
% end
            return BuildDefaultVirtualCallIntrinsic(bc_inst, is_range, acc_read);  // not supported case
% if Compiler::ext_intrinsic_spaces.any?
        }
    }
% end
}
#endif
