/*
 * Copyright (c) 2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "disassembler.h"

namespace panda::disasm {

IdList Disassembler::GetInstructions(pandasm::Function *method, panda_file::File::EntityId method_id,
                           panda_file::File::EntityId code_id) const {
    panda_file::CodeDataAccessor code_accessor(*file_, code_id);

    const auto ins_sz = code_accessor.GetCodeSize();
    const auto ins_arr = code_accessor.GetInstructions();

    method->regs_num = code_accessor.GetNumVregs();

    auto bc_ins = BytecodeInstruction(ins_arr);
    const auto bc_ins_last = bc_ins.JumpTo(ins_sz);

    LabelTable label_table = GetExceptions(method, method_id, code_id);

    IdList unknown_external_methods{};

    while (bc_ins.GetAddress() != bc_ins_last.GetAddress()) {
        if (bc_ins.GetAddress() > bc_ins_last.GetAddress()) {
            LOG(ERROR, DISASSEMBLER) << "> error encountered at " << std::dec << code_id.GetOffset() << " (" << "0x" << std::hex
                                     << code_id.GetOffset() << "). bytecode instructions sequence corrupted for method "
                                     << method->name << "! went out of bounds";

            break;
        }

        auto pa_ins = BytecodeInstructionToPandasmInstruction(bc_ins, method_id, method->language);

        // alter instructions operands depending on instruction type
        if (pa_ins.IsConditionalJump() || pa_ins.IsJump()) {
            const int32_t jmp_offset = std::get<int64_t>(pa_ins.imms.at(0));
            const auto bc_ins_dest = bc_ins.JumpTo(jmp_offset);
            if (bc_ins_last.GetAddress() > bc_ins_dest.GetAddress()) {
                size_t idx = GetBytecodeInstructionNumber(BytecodeInstruction(ins_arr), bc_ins_dest);

                if (idx != std::numeric_limits<size_t>::max()) {
                    if (label_table.find(idx) == label_table.end()) {
                        std::stringstream ss{};
                        ss << "jump_label_" << label_table.size();
                        label_table[idx] = ss.str();
                    }

                    pa_ins.imms.clear();
                    pa_ins.ids.push_back(label_table[idx]);
                } else {
                    LOG(ERROR, DISASSEMBLER) << "> error encountered at " << std::dec << code_id.GetOffset() << " ("
                                             << "0x" << std::hex << code_id.GetOffset() << "). incorrect instruction at offset "
                                             << (bc_ins.GetAddress() - ins_arr) << ": invalid jump offset "
                                             << jmp_offset << " - jumping in the middle of another instruction!";

                }
            } else {
                LOG(ERROR, DISASSEMBLER) << "> error encountered at " << std::dec << code_id.GetOffset() << " ("
                                         << "0x" << std::hex << code_id.GetOffset()
                                         << "). incorrect instruction at offset: " << (bc_ins.GetAddress() - ins_arr)
                                         << ": invalid jump offset " << jmp_offset << " - jumping out of bounds!";
            }
        }

        // if builtin - change imm to mnemonic
        switch (pa_ins.opcode) {
% PandaBuiltins::instructions.each do |insn|
        case pandasm::Opcode::<%=insn.mnemonic.tr('.', '_').upcase%>:
            switch(pa_ins.imms[0].index()) {
            // contains int64_t
            case 0:
                switch (std::get<int64_t>(pa_ins.imms[0])) {
% PandaBuiltins::builtins.each do |builtin|
% if (builtin.insn == insn.mnemonic)
                case <%= builtin.id%>:
                    pa_ins.ids.insert(pa_ins.ids.begin(), std::string("<%=builtin.mnemonic%>"));
                    break;
% end
% end
                default:
                    LOG(ERROR, DISASSEMBLER) << "> error encountered at " << std::dec << code_id.GetOffset() << " ("
                                             << "0x" << std::hex << code_id.GetOffset()
                                             << "). incorrect builtin mnemonic id!";
                    break;
                }

                break;
            // float or nothing - throw error
            default:
                LOG(ERROR, DISASSEMBLER) << "> error encountered at " << std::dec << code_id.GetOffset() << " ("
                                             << "0x" << std::hex << code_id.GetOffset()
                                             << "). incorrect type of builtin mnemonic id! expected integer, but "
                                                "float (or nothing) received!";
                break;
            }
            pa_ins.imms.erase(pa_ins.imms.begin());

            break;
% end
        default:
            break;
        }

        // check if method id is unknown external method. if so, emplace it in table
        if (bc_ins.HasFlag(BytecodeInstruction::Flags::METHOD_ID)) {
            const auto arg_method_idx = bc_ins.GetId().AsIndex();
            const auto arg_method_id = file_->ResolveMethodIndex(method_id, arg_method_idx);

            const auto arg_method_name = GetFullMethodName(arg_method_id, method->language);

            const bool is_present = prog_.function_table.find(arg_method_name) != prog_.function_table.cend();
            const bool is_external = file_->IsExternal(arg_method_id);
            if (is_external && !is_present) {
                unknown_external_methods.push_back(arg_method_id);
            }
        }

        method->ins.push_back(pa_ins);
        bc_ins = bc_ins.GetNext();
    }

    for (const auto& pair : label_table) {
        method->ins[pair.first].label = pair.second;
        method->ins[pair.first].set_label = true;
    }

    return unknown_external_methods;
}

} // namespace panda::disasm
